/* tracker-search-tool.c generated by valac 0.12.0, the Vala compiler
 * generated from tracker-search-tool.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <dbus/dbus.h>
#include <dbus/dbus-glib.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <stdio.h>
#include <gdk/gdk.h>


#define TYPE_TRACKER_SEARCH_TOOL_SERVER (tracker_search_tool_server_get_type ())
#define TRACKER_SEARCH_TOOL_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_SEARCH_TOOL_SERVER, TrackerSearchToolServer))
#define TRACKER_SEARCH_TOOL_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_SEARCH_TOOL_SERVER, TrackerSearchToolServerClass))
#define IS_TRACKER_SEARCH_TOOL_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_SEARCH_TOOL_SERVER))
#define IS_TRACKER_SEARCH_TOOL_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_SEARCH_TOOL_SERVER))
#define TRACKER_SEARCH_TOOL_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_SEARCH_TOOL_SERVER, TrackerSearchToolServerClass))

typedef struct _TrackerSearchToolServer TrackerSearchToolServer;
typedef struct _TrackerSearchToolServerClass TrackerSearchToolServerClass;
typedef struct _TrackerSearchToolServerPrivate TrackerSearchToolServerPrivate;
typedef struct _DBusObjectVTable _DBusObjectVTable;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))

#define TYPE_TRACKER_QUERY (tracker_query_get_type ())
#define TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_QUERY, TrackerQuery))
#define TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_QUERY, TrackerQueryClass))
#define IS_TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_QUERY))
#define IS_TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_QUERY))
#define TRACKER_QUERY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_QUERY, TrackerQueryClass))

typedef struct _TrackerQuery TrackerQuery;
typedef struct _TrackerQueryClass TrackerQueryClass;

#define TYPE_TRACKER_SEARCH_ENTRY (tracker_search_entry_get_type ())
#define TRACKER_SEARCH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_SEARCH_ENTRY, TrackerSearchEntry))
#define TRACKER_SEARCH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_SEARCH_ENTRY, TrackerSearchEntryClass))
#define IS_TRACKER_SEARCH_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_SEARCH_ENTRY))
#define IS_TRACKER_SEARCH_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_SEARCH_ENTRY))
#define TRACKER_SEARCH_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_SEARCH_ENTRY, TrackerSearchEntryClass))

typedef struct _TrackerSearchEntry TrackerSearchEntry;
typedef struct _TrackerSearchEntryClass TrackerSearchEntryClass;

#define TYPE_TRACKER_RESULT_GRID (tracker_result_grid_get_type ())
#define TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGrid))
#define TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))
#define IS_TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_RESULT_GRID))
#define IS_TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_RESULT_GRID))
#define TRACKER_RESULT_GRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))

typedef struct _TrackerResultGrid TrackerResultGrid;
typedef struct _TrackerResultGridClass TrackerResultGridClass;

#define TYPE_TRACKER_CATEGORY_VIEW (tracker_category_view_get_type ())
#define TRACKER_CATEGORY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_CATEGORY_VIEW, TrackerCategoryView))
#define TRACKER_CATEGORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_CATEGORY_VIEW, TrackerCategoryViewClass))
#define IS_TRACKER_CATEGORY_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_CATEGORY_VIEW))
#define IS_TRACKER_CATEGORY_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_CATEGORY_VIEW))
#define TRACKER_CATEGORY_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_CATEGORY_VIEW, TrackerCategoryViewClass))

typedef struct _TrackerCategoryView TrackerCategoryView;
typedef struct _TrackerCategoryViewClass TrackerCategoryViewClass;

#define TYPE_TRACKER_METADATA_TILE (tracker_metadata_tile_get_type ())
#define TRACKER_METADATA_TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_METADATA_TILE, TrackerMetadataTile))
#define TRACKER_METADATA_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_METADATA_TILE, TrackerMetadataTileClass))
#define IS_TRACKER_METADATA_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_METADATA_TILE))
#define IS_TRACKER_METADATA_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_METADATA_TILE))
#define TRACKER_METADATA_TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_METADATA_TILE, TrackerMetadataTileClass))

typedef struct _TrackerMetadataTile TrackerMetadataTile;
typedef struct _TrackerMetadataTileClass TrackerMetadataTileClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _TrackerSearchToolServer {
	GObject parent_instance;
	TrackerSearchToolServerPrivate * priv;
};

struct _TrackerSearchToolServerClass {
	GObjectClass parent_class;
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};


extern GtkWindow* window;
GtkWindow* window = NULL;
extern gchar** terms;
extern gint terms_length1;
gchar** terms = NULL;
gint terms_length1 = 0;
extern gchar* search_string;
gchar* search_string = NULL;
extern gboolean print_version;
gboolean print_version = FALSE;
static gpointer tracker_search_tool_server_parent_class = NULL;

#define ABOUT "Tracker " PACKAGE_VERSION "\n"
#define LICENSE "This program is free software and comes without any warranty.\n" "It is licensed under version 2 or later of the General Public " "License which can be viewed at:\n" "\n" "  http://www.gnu.org/licenses/gpl.txt\n"
GType tracker_search_tool_server_get_type (void) G_GNUC_CONST;
enum  {
	TRACKER_SEARCH_TOOL_SERVER_DUMMY_PROPERTY
};
void tracker_search_tool_server_Show (TrackerSearchToolServer* self);
TrackerSearchToolServer* tracker_search_tool_server_new (void);
TrackerSearchToolServer* tracker_search_tool_server_construct (GType object_type);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void tracker_search_tool_server_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _tracker_search_tool_server_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult tracker_search_tool_server_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_tracker_search_tool_server_introspect (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_tracker_search_tool_server_property_get_all (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_tracker_search_tool_server_Show (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message);
void _vala_main (gchar** args, int args_length1);
static guint _dynamic_request_name0 (DBusGProxy* self, const gchar* param1, guint param2, GError** error);
static void _dynamic_show1 (DBusGProxy* self, GError** error);
static void _gtk_main_quit_gtk_object_destroy (GtkWindow* _sender, gpointer self);
TrackerQuery* tracker_query_new (void);
TrackerQuery* tracker_query_construct (GType object_type);
GType tracker_query_get_type (void) G_GNUC_CONST;
TrackerSearchEntry* tracker_search_entry_new (void);
TrackerSearchEntry* tracker_search_entry_construct (GType object_type);
GType tracker_search_entry_get_type (void) G_GNUC_CONST;
TrackerResultGrid* tracker_result_grid_new (void);
TrackerResultGrid* tracker_result_grid_construct (GType object_type);
GType tracker_result_grid_get_type (void) G_GNUC_CONST;
TrackerCategoryView* tracker_category_view_new (void);
TrackerCategoryView* tracker_category_view_construct (GType object_type);
GType tracker_category_view_get_type (void) G_GNUC_CONST;
TrackerMetadataTile* tracker_metadata_tile_new (void);
TrackerMetadataTile* tracker_metadata_tile_construct (GType object_type);
GType tracker_metadata_tile_get_type (void) G_GNUC_CONST;
gboolean tracker_query_Connect (TrackerQuery* self);
void tracker_search_entry_set_Query (TrackerSearchEntry* self, TrackerQuery* value);
void tracker_result_grid_set_Query (TrackerResultGrid* self, TrackerQuery* value);
void tracker_category_view_set_Query (TrackerCategoryView* self, TrackerQuery* value);
void tracker_metadata_tile_set_ResultGrid (TrackerMetadataTile* self, TrackerResultGrid* value);
void tracker_metadata_tile_set_Query (TrackerMetadataTile* self, TrackerQuery* value);

const GOptionEntry options[3] = {{"version", 'V', 0, G_OPTION_ARG_NONE, &print_version, "Print version", NULL}, {"", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &terms, "search terms", NULL}, {NULL}};
static const DBusObjectPathVTable _tracker_search_tool_server_dbus_path_vtable = {_tracker_search_tool_server_dbus_unregister, tracker_search_tool_server_dbus_message};
static const _DBusObjectVTable _tracker_search_tool_server_dbus_vtable = {tracker_search_tool_server_dbus_register_object};

void tracker_search_tool_server_Show (TrackerSearchToolServer* self) {
	g_return_if_fail (self != NULL);
	gtk_window_present (window);
}


TrackerSearchToolServer* tracker_search_tool_server_construct (GType object_type) {
	TrackerSearchToolServer * self = NULL;
	self = (TrackerSearchToolServer*) g_object_new (object_type, NULL);
	return self;
}


TrackerSearchToolServer* tracker_search_tool_server_new (void) {
	return tracker_search_tool_server_construct (TYPE_TRACKER_SEARCH_TOOL_SERVER);
}


static void tracker_search_tool_server_class_init (TrackerSearchToolServerClass * klass) {
	tracker_search_tool_server_parent_class = g_type_class_peek_parent (klass);
}


static void tracker_search_tool_server_instance_init (TrackerSearchToolServer * self) {
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void _tracker_search_tool_server_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_tracker_search_tool_server_introspect (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.Tracker1.SearchTool\">\n  <method name=\"Show\">\n  </method>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_tracker_search_tool_server_property_get_all (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "org.freedesktop.Tracker1.SearchTool") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_tracker_search_tool_server_Show (TrackerSearchToolServer* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	tracker_search_tool_server_Show (self);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult tracker_search_tool_server_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_tracker_search_tool_server_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_tracker_search_tool_server_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.Tracker1.SearchTool", "Show")) {
		result = _dbus_tracker_search_tool_server_Show (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void tracker_search_tool_server_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_tracker_search_tool_server_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
}


GType tracker_search_tool_server_get_type (void) {
	static volatile gsize tracker_search_tool_server_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_search_tool_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TrackerSearchToolServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tracker_search_tool_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TrackerSearchToolServer), 0, (GInstanceInitFunc) tracker_search_tool_server_instance_init, NULL };
		GType tracker_search_tool_server_type_id;
		tracker_search_tool_server_type_id = g_type_register_static (G_TYPE_OBJECT, "TrackerSearchToolServer", &g_define_type_info, 0);
		g_type_set_qdata (tracker_search_tool_server_type_id, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_tracker_search_tool_server_dbus_vtable));
		g_once_init_leave (&tracker_search_tool_server_type_id__volatile, tracker_search_tool_server_type_id);
	}
	return tracker_search_tool_server_type_id__volatile;
}


static guint _dynamic_request_name0 (DBusGProxy* self, const gchar* param1, guint param2, GError** error) {
	guint result;
	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0U;
	}
	return result;
}


static void _dynamic_show1 (DBusGProxy* self, GError** error) {
	dbus_g_proxy_call (self, "Show", error, G_TYPE_INVALID, G_TYPE_INVALID);
	if (*error) {
		return;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _gtk_main_quit_gtk_object_destroy (GtkWindow* _sender, gpointer self) {
	gtk_main_quit ();
}


void _vala_main (gchar** args, int args_length1) {
	GOptionContext* _tmp0_ = NULL;
	GOptionContext* option_context;
	TrackerSearchToolServer* _tmp1_ = NULL;
	TrackerSearchToolServer* server;
	DBusGProxy* bus = NULL;
	guint _result_ = 0U;
	DBusGConnection* _tmp2_ = NULL;
	DBusGConnection* conn;
	DBusGProxy* _tmp3_ = NULL;
	guint _tmp4_;
	guint _tmp5_;
	GtkBuilder* _tmp7_ = NULL;
	GtkBuilder* builder;
	GObject* _tmp9_ = NULL;
	GObject* _tmp10_;
	GtkWindow* _tmp11_;
	GtkAccelGroup* _tmp12_ = NULL;
	GtkAccelGroup* accel_group;
	GtkEntry* _tmp13_ = NULL;
	GtkEntry* entry;
	TrackerQuery* _tmp14_ = NULL;
	TrackerQuery* query;
	TrackerSearchEntry* _tmp15_ = NULL;
	TrackerSearchEntry* search_entry;
	TrackerResultGrid* _tmp16_ = NULL;
	TrackerResultGrid* grid;
	TrackerCategoryView* _tmp17_ = NULL;
	TrackerCategoryView* categories;
	TrackerMetadataTile* _tmp18_ = NULL;
	TrackerMetadataTile* tile;
	GObject* _tmp19_ = NULL;
	GObject* _tmp20_;
	GtkContainer* _tmp21_;
	GtkContainer* entry_box;
	GObject* _tmp22_ = NULL;
	GObject* _tmp23_;
	GtkContainer* _tmp24_;
	GtkContainer* grid_box;
	GObject* _tmp25_ = NULL;
	GObject* _tmp26_;
	GtkContainer* _tmp27_;
	GtkContainer* category_box;
	GObject* _tmp28_ = NULL;
	GObject* _tmp29_;
	GtkVBox* _tmp30_;
	GtkVBox* main_box;
	GObject* _tmp31_ = NULL;
	GObject* _tmp32_;
	GtkLabel* _tmp33_;
	GtkLabel* search_label;
	guint keyval = 0U;
	GdkModifierType mods = 0;
	guint _tmp34_;
	GdkModifierType _tmp35_;
	GtkWidget* _tmp36_ = NULL;
	GtkWidget* _tmp37_;
	GtkEntry* _tmp38_;
	GtkAlignment* _tmp39_ = NULL;
	GtkAlignment* a;
	GError * _inner_error_ = NULL;
	gtk_init (&args_length1, &args);
	_tmp0_ = g_option_context_new ("tracker-search-tool");
	option_context = _tmp0_;
	g_option_context_set_help_enabled (option_context, TRUE);
	g_option_context_add_main_entries (option_context, options, NULL);
	g_option_context_parse (option_context, &args_length1, &args, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_OPTION_ERROR) {
			goto __catch4_g_option_error;
		}
		_g_option_context_free0 (option_context);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	goto __finally4;
	__catch4_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "%s\n", e->message);
		fprintf (stdout, "Run '%s --help' to see a full list of available command line options.\n", args[0]);
		_g_error_free0 (e);
		_g_option_context_free0 (option_context);
		return;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (option_context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (print_version) {
		fprintf (stdout, "%s", "\n" ABOUT "\n" LICENSE "\n");
		_g_option_context_free0 (option_context);
		return;
	}
	_tmp1_ = tracker_search_tool_server_new ();
	server = _tmp1_;
	_tmp2_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
	conn = _tmp2_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (bus);
		if (_inner_error_->domain == DBUS_GERROR) {
			goto __catch5_dbus_gerror;
		}
		_g_object_unref0 (bus);
		_g_object_unref0 (server);
		_g_option_context_free0 (option_context);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = dbus_g_proxy_new_for_name (conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus");
	_g_object_unref0 (bus);
	bus = _tmp3_;
	_tmp4_ = _dynamic_request_name0 (bus, "org.freedesktop.Tracker1.SearchTool", (guint) 0, &_inner_error_);
	_tmp5_ = _tmp4_;
	if (_inner_error_ != NULL) {
		_dbus_g_connection_unref0 (conn);
		_g_object_unref0 (bus);
		if (_inner_error_->domain == DBUS_GERROR) {
			goto __catch5_dbus_gerror;
		}
		goto __finally5;
	}
	_result_ = _tmp5_;
	if (_result_ == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
		_vala_dbus_register_object (dbus_g_connection_get_connection (conn), "/org/freedesktop/Tracker1/SearchTool", (GObject*) server);
	} else {
		DBusGProxy* remote = NULL;
		DBusGProxy* _tmp6_ = NULL;
		_tmp6_ = dbus_g_proxy_new_for_name (conn, "org.freedesktop.Tracker1.SearchTool", "/org/freedesktop/Tracker1/SearchTool", "org.freedesktop.Tracker1.SearchTool");
		_g_object_unref0 (remote);
		remote = _tmp6_;
		_dynamic_show1 (remote, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (remote);
			_dbus_g_connection_unref0 (conn);
			_g_object_unref0 (bus);
			if (_inner_error_->domain == DBUS_GERROR) {
				goto __catch5_dbus_gerror;
			}
			goto __finally5;
		}
		_g_object_unref0 (remote);
		_dbus_g_connection_unref0 (conn);
		_g_object_unref0 (bus);
		_g_object_unref0 (server);
		_g_option_context_free0 (option_context);
		return;
	}
	_dbus_g_connection_unref0 (conn);
	_g_object_unref0 (bus);
	goto __finally5;
	__catch5_dbus_gerror:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("tracker-search-tool.gs:96: %s", e->message);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (server);
		_g_option_context_free0 (option_context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp7_ = gtk_builder_new ();
	builder = _tmp7_;
	gtk_builder_add_from_file (builder, SRCDIR "tst.ui", &_inner_error_);
	if (_inner_error_ != NULL) {
		goto __catch6_g_error;
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		gtk_builder_add_from_file (builder, TRACKER_UI_DIR "tst.ui", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch7_g_error;
		}
		goto __finally7;
		__catch7_g_error:
		{
			GError * e;
			GtkMessageDialog* _tmp8_ = NULL;
			GtkMessageDialog* msg;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = (GtkMessageDialog*) gtk_message_dialog_new (NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_ERROR, GTK_BUTTONS_OK, "Failed to load UI\n%s", e->message);
			msg = g_object_ref_sink (_tmp8_);
			gtk_dialog_run ((GtkDialog*) msg);
			gtk_main_quit ();
			_g_object_unref0 (msg);
			_g_error_free0 (e);
		}
		__finally7:
		if (_inner_error_ != NULL) {
			_g_error_free0 (e);
			_g_error_free0 (e);
			_g_object_unref0 (builder);
			_g_object_unref0 (server);
			_g_option_context_free0 (option_context);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		_g_object_unref0 (server);
		_g_option_context_free0 (option_context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp9_ = gtk_builder_get_object (builder, "window");
	_tmp10_ = _tmp9_;
	_tmp11_ = _g_object_ref0 (GTK_IS_WINDOW (_tmp10_) ? ((GtkWindow*) _tmp10_) : NULL);
	_g_object_unref0 (window);
	window = _tmp11_;
	g_signal_connect ((GtkObject*) window, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
	_tmp12_ = gtk_accel_group_new ();
	accel_group = _tmp12_;
	_tmp13_ = (GtkEntry*) gtk_entry_new ();
	entry = g_object_ref_sink (_tmp13_);
	_tmp14_ = tracker_query_new ();
	query = _tmp14_;
	_tmp15_ = tracker_search_entry_new ();
	search_entry = g_object_ref_sink (_tmp15_);
	_tmp16_ = tracker_result_grid_new ();
	grid = g_object_ref_sink (_tmp16_);
	_tmp17_ = tracker_category_view_new ();
	categories = g_object_ref_sink (_tmp17_);
	_tmp18_ = tracker_metadata_tile_new ();
	tile = g_object_ref_sink (_tmp18_);
	_tmp19_ = gtk_builder_get_object (builder, "EntryBox");
	_tmp20_ = _tmp19_;
	_tmp21_ = _g_object_ref0 (GTK_IS_CONTAINER (_tmp20_) ? ((GtkContainer*) _tmp20_) : NULL);
	entry_box = _tmp21_;
	_tmp22_ = gtk_builder_get_object (builder, "GridBox");
	_tmp23_ = _tmp22_;
	_tmp24_ = _g_object_ref0 (GTK_IS_CONTAINER (_tmp23_) ? ((GtkContainer*) _tmp23_) : NULL);
	grid_box = _tmp24_;
	_tmp25_ = gtk_builder_get_object (builder, "CategoryBox");
	_tmp26_ = _tmp25_;
	_tmp27_ = _g_object_ref0 (GTK_IS_CONTAINER (_tmp26_) ? ((GtkContainer*) _tmp26_) : NULL);
	category_box = _tmp27_;
	_tmp28_ = gtk_builder_get_object (builder, "MainBox");
	_tmp29_ = _tmp28_;
	_tmp30_ = _g_object_ref0 (GTK_IS_VBOX (_tmp29_) ? ((GtkVBox*) _tmp29_) : NULL);
	main_box = _tmp30_;
	_tmp31_ = gtk_builder_get_object (builder, "SearchLabel");
	_tmp32_ = _tmp31_;
	_tmp33_ = _g_object_ref0 (GTK_IS_LABEL (_tmp32_) ? ((GtkLabel*) _tmp32_) : NULL);
	search_label = _tmp33_;
	gtk_window_add_accel_group (window, accel_group);
	gtk_label_set_mnemonic_widget (search_label, (GtkWidget*) search_entry);
	tracker_query_Connect (query);
	tracker_search_entry_set_Query (search_entry, query);
	gtk_container_add (entry_box, (GtkWidget*) search_entry);
	gtk_accelerator_parse ("<Ctrl>s", &_tmp34_, &_tmp35_);
	keyval = _tmp34_;
	mods = _tmp35_;
	_tmp36_ = gtk_bin_get_child ((GtkBin*) search_entry);
	_tmp37_ = _tmp36_;
	_tmp38_ = _g_object_ref0 (GTK_IS_ENTRY (_tmp37_) ? ((GtkEntry*) _tmp37_) : NULL);
	_g_object_unref0 (entry);
	entry = _tmp38_;
	gtk_widget_add_accelerator ((GtkWidget*) entry, "activate", accel_group, keyval, mods, GTK_ACCEL_VISIBLE | GTK_ACCEL_LOCKED);
	tracker_result_grid_set_Query (grid, query);
	gtk_container_add (grid_box, (GtkWidget*) grid);
	tracker_category_view_set_Query (categories, query);
	gtk_container_add (category_box, (GtkWidget*) categories);
	tracker_metadata_tile_set_ResultGrid (tile, grid);
	tracker_metadata_tile_set_Query (tile, query);
	_tmp39_ = (GtkAlignment*) gtk_alignment_new (0.5f, 0.5f, 1.0f, 0.5f);
	a = g_object_ref_sink (_tmp39_);
	gtk_container_add ((GtkContainer*) a, (GtkWidget*) tile);
	gtk_box_pack_end ((GtkBox*) main_box, (GtkWidget*) a, FALSE, FALSE, (guint) 0);
	gtk_widget_show_all ((GtkWidget*) window);
	if (terms != NULL) {
		gchar* _tmp40_ = NULL;
		_tmp40_ = g_strjoinv (" ", terms);
		_g_free0 (search_string);
		search_string = _tmp40_;
		gtk_entry_set_text (entry, search_string);
	}
	gtk_main ();
	_g_object_unref0 (a);
	_g_object_unref0 (search_label);
	_g_object_unref0 (main_box);
	_g_object_unref0 (category_box);
	_g_object_unref0 (grid_box);
	_g_object_unref0 (entry_box);
	_g_object_unref0 (tile);
	_g_object_unref0 (categories);
	_g_object_unref0 (grid);
	_g_object_unref0 (search_entry);
	_g_object_unref0 (query);
	_g_object_unref0 (entry);
	_g_object_unref0 (accel_group);
	_g_object_unref0 (builder);
	_g_object_unref0 (server);
	_g_option_context_free0 (option_context);
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main (argv, argc);
	return 0;
}



