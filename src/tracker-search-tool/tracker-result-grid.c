/* tracker-result-grid.c generated by valac 0.12.0, the Vala compiler
 * generated from tracker-result-grid.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gio/gdesktopappinfo.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define TYPE_RESULT_COLUMNS (result_columns_get_type ())

#define TYPE_TRACKER_RESULT_GRID (tracker_result_grid_get_type ())
#define TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGrid))
#define TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))
#define IS_TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_RESULT_GRID))
#define IS_TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_RESULT_GRID))
#define TRACKER_RESULT_GRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))

typedef struct _TrackerResultGrid TrackerResultGrid;
typedef struct _TrackerResultGridClass TrackerResultGridClass;
typedef struct _TrackerResultGridPrivate TrackerResultGridPrivate;

#define TYPE_TRACKER_QUERY (tracker_query_get_type ())
#define TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_QUERY, TrackerQuery))
#define TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_QUERY, TrackerQueryClass))
#define IS_TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_QUERY))
#define IS_TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_QUERY))
#define TRACKER_QUERY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_QUERY, TrackerQueryClass))

typedef struct _TrackerQuery TrackerQuery;
typedef struct _TrackerQueryClass TrackerQueryClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__gtk_tree_path_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__gtk_tree_path_free0_ (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	RESULT_COLUMNS_Id,
	RESULT_COLUMNS_Uri,
	RESULT_COLUMNS_Icon,
	RESULT_COLUMNS_DisplayName,
	RESULT_COLUMNS_Mime,
	RESULT_COLUMNS_Category,
	RESULT_COLUMNS_Snippet,
	RESULT_COLUMNS_IsDirectory,
	RESULT_COLUMNS_Path,
	RESULT_COLUMNS_NumOfCols
} ResultColumns;

struct _TrackerResultGrid {
	GtkScrolledWindow parent_instance;
	TrackerResultGridPrivate * priv;
	GtkListStore* store;
	GtkIconView* iconview;
};

struct _TrackerResultGridClass {
	GtkScrolledWindowClass parent_class;
};

struct _TrackerResultGridPrivate {
	TrackerQuery* _query;
};


static gpointer tracker_result_grid_parent_class = NULL;

GType result_columns_get_type (void) G_GNUC_CONST;
GType tracker_result_grid_get_type (void) G_GNUC_CONST;
GType tracker_query_get_type (void) G_GNUC_CONST;
#define TRACKER_RESULT_GRID_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TRACKER_RESULT_GRID, TrackerResultGridPrivate))
enum  {
	TRACKER_RESULT_GRID_DUMMY_PROPERTY,
	TRACKER_RESULT_GRID_QUERY
};
GtkTreePath* tracker_result_grid_GetSelectedPath (TrackerResultGrid* self);
static void _gtk_tree_path_free0_ (gpointer var);
static void _g_list_free__gtk_tree_path_free0_ (GList* self);
const gchar* tracker_result_grid_GetSelectedUri (TrackerResultGrid* self);
void tracker_result_grid_RefreshQuery (TrackerResultGrid* self);
gchar** tracker_query_Search (TrackerQuery* self, int* result_length1, int* result_length2);
TrackerQuery* tracker_result_grid_get_Query (TrackerResultGrid* self);
gchar** tracker_query_Query (TrackerQuery* self, const gchar* sparql, int* result_length1, int* result_length2);
GdkPixbuf* tracker_utils_GetThemeIconPixbuf (GIcon* icon, gint size, GdkScreen* screen);
GdkPixbuf* tracker_utils_GetThumbNail (GFileInfo* info, gint thumb_size, gint icon_size, GdkScreen* screen);
GdkPixbuf* tracker_utils_GetThemePixbufByName (const gchar* icon_name, gint size, GdkScreen* screen);
void tracker_result_grid_ActivateUri (TrackerResultGrid* self, GtkTreePath* path);
gboolean tracker_utils_LaunchApp (const gchar* uri);
gboolean tracker_utils_OpenUri (const gchar* uri, gboolean is_dir);
TrackerResultGrid* tracker_result_grid_new (void);
TrackerResultGrid* tracker_result_grid_construct (GType object_type);
void tracker_result_grid_set_Query (TrackerResultGrid* self, TrackerQuery* value);
static void _lambda2_ (TrackerResultGrid* self);
static void __lambda2__tracker_query_search_settings_changed (TrackerQuery* _sender, gpointer self);
static void _lambda3_ (TrackerResultGrid* self);
static void __lambda3__tracker_query_clear_search_results (TrackerQuery* _sender, gpointer self);
static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static GObject * tracker_result_grid_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated (GtkIconView* _sender, GtkTreePath* path, gpointer self);
static void _lambda4_ (TrackerResultGrid* self);
static void __lambda4__gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self);
static void _lambda5_ (GdkDragContext* context, GtkSelectionData* data, guint info, guint time, TrackerResultGrid* self);
static void __lambda5__gtk_widget_drag_data_get (GtkIconView* _sender, GdkDragContext* context, GtkSelectionData* selection_data, guint info, guint time_, gpointer self);
static void tracker_result_grid_finalize (GObject* obj);
static void _vala_tracker_result_grid_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_tracker_result_grid_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const GtkTargetEntry targets[3] = {{"text/uri-list", (guint) 0, (guint) 1}, {"text/plain", (guint) 0, (guint) 0}, {"STRING", (guint) 0, (guint) 0}};

GType result_columns_get_type (void) {
	static volatile gsize result_columns_type_id__volatile = 0;
	if (g_once_init_enter (&result_columns_type_id__volatile)) {
		static const GEnumValue values[] = {{RESULT_COLUMNS_Id, "RESULT_COLUMNS_Id", "id"}, {RESULT_COLUMNS_Uri, "RESULT_COLUMNS_Uri", "uri"}, {RESULT_COLUMNS_Icon, "RESULT_COLUMNS_Icon", "icon"}, {RESULT_COLUMNS_DisplayName, "RESULT_COLUMNS_DisplayName", "displayname"}, {RESULT_COLUMNS_Mime, "RESULT_COLUMNS_Mime", "mime"}, {RESULT_COLUMNS_Category, "RESULT_COLUMNS_Category", "category"}, {RESULT_COLUMNS_Snippet, "RESULT_COLUMNS_Snippet", "snippet"}, {RESULT_COLUMNS_IsDirectory, "RESULT_COLUMNS_IsDirectory", "isdirectory"}, {RESULT_COLUMNS_Path, "RESULT_COLUMNS_Path", "path"}, {RESULT_COLUMNS_NumOfCols, "RESULT_COLUMNS_NumOfCols", "numofcols"}, {0, NULL, NULL}};
		GType result_columns_type_id;
		result_columns_type_id = g_enum_register_static ("ResultColumns", values);
		g_once_init_leave (&result_columns_type_id__volatile, result_columns_type_id);
	}
	return result_columns_type_id__volatile;
}


static void _gtk_tree_path_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL));
}


static void _g_list_free__gtk_tree_path_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _gtk_tree_path_free0_, NULL);
	g_list_free (self);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


GtkTreePath* tracker_result_grid_GetSelectedPath (TrackerResultGrid* self) {
	GtkTreePath* result = NULL;
	GList* _tmp0_ = NULL;
	GList* _tmp1_;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gtk_icon_view_get_selected_items (self->iconview);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_ != NULL;
	__g_list_free__gtk_tree_path_free0_0 (_tmp1_);
	if (_tmp2_) {
		GList* _tmp3_ = NULL;
		GList* _tmp4_;
		GtkTreePath* _tmp5_;
		GtkTreePath* _tmp6_;
		_tmp3_ = gtk_icon_view_get_selected_items (self->iconview);
		_tmp4_ = _tmp3_;
		_tmp5_ = _gtk_tree_path_copy0 ((GtkTreePath*) ((GtkTreePath*) _tmp4_->data));
		_tmp6_ = _tmp5_;
		__g_list_free__gtk_tree_path_free0_0 (_tmp4_);
		result = _tmp6_;
		return result;
	}
	result = NULL;
	return result;
}


const gchar* tracker_result_grid_GetSelectedUri (TrackerResultGrid* self) {
	const gchar* result = NULL;
	GtkTreeIter iter = {0};
	const gchar* uri = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* path;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = tracker_result_grid_GetSelectedPath (self);
	path = _tmp0_;
	if (path != NULL) {
		GtkTreeIter _tmp1_ = {0};
		gtk_tree_model_get_iter ((GtkTreeModel*) self->store, &_tmp1_, path);
		iter = _tmp1_;
		gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_Uri, &uri, -1);
		result = uri;
		_gtk_tree_path_free0 (path);
		return result;
	}
	result = "";
	_gtk_tree_path_free0 (path);
	return result;
}


static gboolean string_contains (const gchar* self, const gchar* needle) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


void tracker_result_grid_RefreshQuery (TrackerResultGrid* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (self->priv->_query != NULL) {
		gint _tmp0_;
		gint _tmp1_;
		gchar** _tmp2_ = NULL;
		gchar** results;
		gint results_length1;
		gint results_length2;
		gboolean has_results;
		GtkTreeIter iter = {0};
		gint i;
		_tmp2_ = tracker_query_Search (self->priv->_query, &_tmp0_, &_tmp1_);
		results = _tmp2_;
		results_length1 = _tmp0_;
		results_length2 = _tmp1_;
		has_results = FALSE;
		gtk_list_store_clear (self->store);
		if (results == NULL) {
			results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
			return;
		}
		i = 0;
		while (TRUE) {
			gchar* _tmp3_;
			gchar* uri;
			gchar* _tmp4_;
			gchar* id;
			gchar* _tmp5_;
			gchar* mime;
			gboolean _tmp6_;
			if (!(results[i] != NULL)) {
				break;
			}
			_tmp3_ = g_strdup (results[i + 1]);
			uri = _tmp3_;
			_tmp4_ = g_strdup (results[i]);
			id = _tmp4_;
			_tmp5_ = g_strdup (results[i + 2]);
			mime = _tmp5_;
			i = i + 3;
			_tmp6_ = g_str_has_prefix (uri, "file://");
			if (_tmp6_) {
				gboolean handled;
				GFile* _tmp7_ = NULL;
				GFile* file;
				gchar* _tmp8_ = NULL;
				gchar* query;
				TrackerQuery* _tmp9_ = NULL;
				gint _tmp10_;
				gint _tmp11_;
				gchar** _tmp12_ = NULL;
				gchar** qresults;
				gint qresults_length1;
				gint qresults_length2;
				gboolean _tmp13_ = FALSE;
				has_results = TRUE;
				handled = FALSE;
				_tmp7_ = g_file_new_for_uri (uri);
				file = _tmp7_;
				_tmp8_ = g_strdup_printf ("SELECT rdf:type(?s) where { ?s nie:url \"%s\" }", uri);
				query = _tmp8_;
				_tmp9_ = tracker_result_grid_get_Query (self);
				_tmp12_ = tracker_query_Query (_tmp9_, query, &_tmp10_, &_tmp11_);
				qresults = _tmp12_;
				qresults_length1 = _tmp10_;
				qresults_length2 = _tmp11_;
				if (qresults != NULL) {
					gboolean _tmp14_;
					_tmp14_ = string_contains (qresults[0], "nfo#Software");
					_tmp13_ = _tmp14_;
				} else {
					_tmp13_ = FALSE;
				}
				if (_tmp13_) {
					GAppInfo* app_info = NULL;
					gchar* _tmp15_ = NULL;
					gchar* _tmp16_;
					GDesktopAppInfo* _tmp17_ = NULL;
					_tmp15_ = g_file_get_path (file);
					_tmp16_ = _tmp15_;
					_tmp17_ = g_desktop_app_info_new_from_filename (_tmp16_);
					_g_object_unref0 (app_info);
					app_info = (GAppInfo*) _tmp17_;
					_g_free0 (_tmp16_);
					if (app_info != NULL) {
						GtkTreeIter _tmp18_ = {0};
						GIcon* _tmp19_ = NULL;
						GdkScreen* _tmp20_ = NULL;
						GdkPixbuf* _tmp21_ = NULL;
						GdkPixbuf* _tmp22_;
						const gchar* _tmp23_ = NULL;
						gtk_list_store_append (self->store, &_tmp18_);
						iter = _tmp18_;
						_tmp19_ = g_app_info_get_icon (app_info);
						_tmp20_ = gtk_widget_get_screen ((GtkWidget*) self);
						_tmp21_ = tracker_utils_GetThemeIconPixbuf (_tmp19_, 48, _tmp20_);
						_tmp22_ = _tmp21_;
						_tmp23_ = g_app_info_get_display_name (app_info);
						gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp22_, RESULT_COLUMNS_DisplayName, _tmp23_, RESULT_COLUMNS_IsDirectory, FALSE, -1, -1);
						_g_object_unref0 (_tmp22_);
						handled = TRUE;
					}
					_g_object_unref0 (app_info);
				}
				if (!handled) {
					GFileInfo* _tmp24_ = NULL;
					GFileInfo* info;
					GFileType _tmp25_;
					GFileType filetype;
					GtkTreeIter _tmp26_ = {0};
					GdkScreen* _tmp27_ = NULL;
					GdkPixbuf* _tmp28_ = NULL;
					GdkPixbuf* _tmp29_;
					const gchar* _tmp30_ = NULL;
					_tmp24_ = g_file_query_info (file, "standard::display-name,standard::icon,thumbnail::path", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
					info = _tmp24_;
					if (_inner_error_ != NULL) {
						goto __catch3_g_error;
					}
					_tmp25_ = g_file_info_get_file_type (info);
					filetype = _tmp25_;
					gtk_list_store_append (self->store, &_tmp26_);
					iter = _tmp26_;
					_tmp27_ = gtk_widget_get_screen ((GtkWidget*) self);
					_tmp28_ = tracker_utils_GetThumbNail (info, 64, 48, _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp30_ = g_file_info_get_display_name (info);
					gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp29_, RESULT_COLUMNS_DisplayName, _tmp30_, RESULT_COLUMNS_IsDirectory, filetype == G_FILE_TYPE_DIRECTORY, -1, -1);
					_g_object_unref0 (_tmp29_);
					_g_object_unref0 (info);
					goto __finally3;
					__catch3_g_error:
					{
						GError * e;
						e = _inner_error_;
						_inner_error_ = NULL;
						g_print ("Could not get file info for %s\n", uri);
						_g_error_free0 (e);
					}
					__finally3:
					if (_inner_error_ != NULL) {
						qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
						_g_free0 (query);
						_g_object_unref0 (file);
						_g_free0 (mime);
						_g_free0 (id);
						_g_free0 (uri);
						results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
				_g_free0 (query);
				_g_object_unref0 (file);
			} else {
				gboolean _tmp31_;
				_tmp31_ = g_str_has_prefix (uri, "email://");
				if (_tmp31_) {
					gchar* _tmp32_ = NULL;
					gchar* query;
					TrackerQuery* _tmp33_ = NULL;
					gint _tmp34_;
					gint _tmp35_;
					gchar** _tmp36_ = NULL;
					gchar** qresults;
					gint qresults_length1;
					gint qresults_length2;
					GtkTreeIter _tmp37_ = {0};
					GdkScreen* _tmp38_ = NULL;
					GdkPixbuf* _tmp39_ = NULL;
					GdkPixbuf* _tmp40_;
					_tmp32_ = g_strdup_printf ("SELECT nmo:messageSubject(?s) where { ?s nie:url \"%s\" }", uri);
					query = _tmp32_;
					_tmp33_ = tracker_result_grid_get_Query (self);
					_tmp36_ = tracker_query_Query (_tmp33_, query, &_tmp34_, &_tmp35_);
					qresults = _tmp36_;
					qresults_length1 = _tmp34_;
					qresults_length2 = _tmp35_;
					gtk_list_store_append (self->store, &_tmp37_);
					iter = _tmp37_;
					_tmp38_ = gtk_widget_get_screen ((GtkWidget*) self);
					_tmp39_ = tracker_utils_GetThemePixbufByName ("evolution-mail", 48, _tmp38_);
					_tmp40_ = _tmp39_;
					gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp40_, RESULT_COLUMNS_DisplayName, qresults[0], RESULT_COLUMNS_IsDirectory, FALSE, -1, -1);
					_g_object_unref0 (_tmp40_);
					qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
					_g_free0 (query);
				}
			}
			_g_free0 (mime);
			_g_free0 (id);
			_g_free0 (uri);
		}
		if (has_results) {
			GtkTreePath* _tmp41_ = NULL;
			GtkTreePath* path;
			_tmp41_ = gtk_tree_path_new_from_string ("0:0:0");
			path = _tmp41_;
			if (path != NULL) {
				gtk_icon_view_select_path (self->iconview, path);
			}
			_gtk_tree_path_free0 (path);
		}
		results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
	}
}


void tracker_result_grid_ActivateUri (TrackerResultGrid* self, GtkTreePath* path) {
	GtkTreeIter iter = {0};
	gboolean is_dir;
	GtkTreeIter _tmp0_ = {0};
	const gchar* uri = NULL;
	gchar* _tmp1_ = NULL;
	gchar* query;
	TrackerQuery* _tmp2_ = NULL;
	gint _tmp3_;
	gint _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** results;
	gint results_length1;
	gint results_length2;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	is_dir = FALSE;
	gtk_tree_model_get_iter ((GtkTreeModel*) self->store, &_tmp0_, path);
	iter = _tmp0_;
	gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_Uri, &uri, -1);
	gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_IsDirectory, &is_dir, -1);
	_tmp1_ = g_strdup_printf ("SELECT rdf:type(?s) where { ?s nie:url \"%s\" }", uri);
	query = _tmp1_;
	_tmp2_ = tracker_result_grid_get_Query (self);
	_tmp5_ = tracker_query_Query (_tmp2_, query, &_tmp3_, &_tmp4_);
	results = _tmp5_;
	results_length1 = _tmp3_;
	results_length2 = _tmp4_;
	if (results != NULL) {
		gboolean _tmp7_;
		_tmp7_ = string_contains (results[0], "nfo#Software");
		_tmp6_ = _tmp7_;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		tracker_utils_LaunchApp (uri);
	} else {
		tracker_utils_OpenUri (uri, is_dir);
	}
	results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
	_g_free0 (query);
}


TrackerResultGrid* tracker_result_grid_construct (GType object_type) {
	TrackerResultGrid * self = NULL;
	self = (TrackerResultGrid*) g_object_new (object_type, NULL);
	return self;
}


TrackerResultGrid* tracker_result_grid_new (void) {
	return tracker_result_grid_construct (TYPE_TRACKER_RESULT_GRID);
}


TrackerQuery* tracker_result_grid_get_Query (TrackerResultGrid* self) {
	TrackerQuery* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_query;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _lambda2_ (TrackerResultGrid* self) {
	tracker_result_grid_RefreshQuery (self);
}


static void __lambda2__tracker_query_search_settings_changed (TrackerQuery* _sender, gpointer self) {
	_lambda2_ (self);
}


static void _lambda3_ (TrackerResultGrid* self) {
	gtk_list_store_clear (self->store);
}


static void __lambda3__tracker_query_clear_search_results (TrackerQuery* _sender, gpointer self) {
	_lambda3_ (self);
}


void tracker_result_grid_set_Query (TrackerResultGrid* self, TrackerQuery* value) {
	g_return_if_fail (self != NULL);
	if (value != NULL) {
		TrackerQuery* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_query);
		self->priv->_query = _tmp0_;
		g_signal_connect_object (self->priv->_query, "search-settings-changed", (GCallback) __lambda2__tracker_query_search_settings_changed, self, 0);
		g_signal_connect_object (self->priv->_query, "clear-search-results", (GCallback) __lambda3__tracker_query_clear_search_results, self, 0);
	}
	g_object_notify ((GObject *) self, "Query");
}


static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}


static void _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated (GtkIconView* _sender, GtkTreePath* path, gpointer self) {
	tracker_result_grid_ActivateUri (self, path);
}


static void _lambda4_ (TrackerResultGrid* self) {
	GtkTreePath* _tmp0_ = NULL;
	GtkTreePath* path;
	_tmp0_ = tracker_result_grid_GetSelectedPath (self);
	path = _tmp0_;
	g_signal_emit_by_name (self, "selection-changed", path);
	_gtk_tree_path_free0 (path);
}


static void __lambda4__gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self) {
	_lambda4_ (self);
}


static void _lambda5_ (GdkDragContext* context, GtkSelectionData* data, guint info, guint time, TrackerResultGrid* self) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* uri;
	g_return_if_fail (context != NULL);
	g_return_if_fail (data != NULL);
	_tmp0_ = tracker_result_grid_GetSelectedUri (self);
	_tmp1_ = g_strdup (_tmp0_);
	uri = _tmp1_;
	if (uri != NULL) {
		gchar** _tmp2_ = NULL;
		gchar** s;
		gint s_length1;
		gint _s_size_;
		gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp2_ = g_new0 (gchar*, 1 + 1);
		s = _tmp2_;
		s_length1 = 1;
		_s_size_ = 1;
		_tmp3_ = g_strdup (uri);
		_tmp4_ = _tmp3_;
		_g_free0 (s[0]);
		s[0] = _tmp4_;
		gtk_selection_data_set_uris (data, s);
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_free0 (uri);
}


static void __lambda5__gtk_widget_drag_data_get (GtkIconView* _sender, GdkDragContext* context, GtkSelectionData* selection_data, guint info, guint time_, gpointer self) {
	_lambda5_ (context, selection_data, info, time_, self);
}


static GObject * tracker_result_grid_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	TrackerResultGrid * self;
	GtkListStore* _tmp0_ = NULL;
	GtkIconView* _tmp1_ = NULL;
	parent_class = G_OBJECT_CLASS (tracker_result_grid_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = TRACKER_RESULT_GRID (obj);
	g_object_set ((GtkScrolledWindow*) self, "hscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
	g_object_set ((GtkScrolledWindow*) self, "vscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
	gtk_scrolled_window_set_shadow_type ((GtkScrolledWindow*) self, GTK_SHADOW_ETCHED_OUT);
	_tmp0_ = gtk_list_store_new ((gint) RESULT_COLUMNS_NumOfCols, G_TYPE_STRING, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_STRING);
	_g_object_unref0 (self->store);
	self->store = _tmp0_;
	_tmp1_ = (GtkIconView*) gtk_icon_view_new_with_model ((GtkTreeModel*) self->store);
	_g_object_unref0 (self->iconview);
	self->iconview = g_object_ref_sink (_tmp1_);
	gtk_icon_view_set_pixbuf_column (self->iconview, (gint) RESULT_COLUMNS_Icon);
	gtk_icon_view_set_text_column (self->iconview, (gint) RESULT_COLUMNS_DisplayName);
	gtk_icon_view_set_selection_mode (self->iconview, GTK_SELECTION_BROWSE);
	gtk_icon_view_enable_model_drag_source (self->iconview, GDK_BUTTON1_MASK | GDK_BUTTON2_MASK, targets, G_N_ELEMENTS (targets), (GDK_ACTION_COPY | GDK_ACTION_MOVE) | GDK_ACTION_ASK);
	gtk_icon_view_set_item_width (self->iconview, 150);
	gtk_icon_view_set_row_spacing (self->iconview, 10);
	g_signal_connect_object (self->iconview, "item-activated", (GCallback) _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated, self, 0);
	g_signal_connect_object (self->iconview, "selection-changed", (GCallback) __lambda4__gtk_icon_view_selection_changed, self, 0);
	g_signal_connect_object ((GtkWidget*) self->iconview, "drag-data-get", (GCallback) __lambda5__gtk_widget_drag_data_get, self, 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->iconview);
	gtk_widget_show_all ((GtkWidget*) self);
	return obj;
}


static void tracker_result_grid_class_init (TrackerResultGridClass * klass) {
	tracker_result_grid_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TrackerResultGridPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_tracker_result_grid_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_tracker_result_grid_set_property;
	G_OBJECT_CLASS (klass)->constructor = tracker_result_grid_constructor;
	G_OBJECT_CLASS (klass)->finalize = tracker_result_grid_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_RESULT_GRID_QUERY, g_param_spec_object ("Query", "Query", "Query", TYPE_TRACKER_QUERY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("selection_changed", TYPE_TRACKER_RESULT_GRID, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, GTK_TYPE_TREE_PATH);
}


static void tracker_result_grid_instance_init (TrackerResultGrid * self) {
	self->priv = TRACKER_RESULT_GRID_GET_PRIVATE (self);
}


static void tracker_result_grid_finalize (GObject* obj) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (obj);
	_g_object_unref0 (self->store);
	_g_object_unref0 (self->iconview);
	_g_object_unref0 (self->priv->_query);
	G_OBJECT_CLASS (tracker_result_grid_parent_class)->finalize (obj);
}


GType tracker_result_grid_get_type (void) {
	static volatile gsize tracker_result_grid_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_result_grid_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TrackerResultGridClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tracker_result_grid_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TrackerResultGrid), 0, (GInstanceInitFunc) tracker_result_grid_instance_init, NULL };
		GType tracker_result_grid_type_id;
		tracker_result_grid_type_id = g_type_register_static (GTK_TYPE_SCROLLED_WINDOW, "TrackerResultGrid", &g_define_type_info, 0);
		g_once_init_leave (&tracker_result_grid_type_id__volatile, tracker_result_grid_type_id);
	}
	return tracker_result_grid_type_id__volatile;
}


static void _vala_tracker_result_grid_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (object);
	switch (property_id) {
		case TRACKER_RESULT_GRID_QUERY:
		g_value_set_object (value, tracker_result_grid_get_Query (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_tracker_result_grid_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (object);
	switch (property_id) {
		case TRACKER_RESULT_GRID_QUERY:
		tracker_result_grid_set_Query (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



