/* tracker-result-grid.c generated by valac, the Vala compiler
 * generated from tracker-result-grid.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gio/gdesktopappinfo.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define TYPE_RESULT_COLUMNS (result_columns_get_type ())

#define TYPE_TRACKER_RESULT_GRID (tracker_result_grid_get_type ())
#define TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGrid))
#define TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))
#define IS_TRACKER_RESULT_GRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_RESULT_GRID))
#define IS_TRACKER_RESULT_GRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_RESULT_GRID))
#define TRACKER_RESULT_GRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_RESULT_GRID, TrackerResultGridClass))

typedef struct _TrackerResultGrid TrackerResultGrid;
typedef struct _TrackerResultGridClass TrackerResultGridClass;
typedef struct _TrackerResultGridPrivate TrackerResultGridPrivate;

#define TYPE_TRACKER_QUERY (tracker_query_get_type ())
#define TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACKER_QUERY, TrackerQuery))
#define TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACKER_QUERY, TrackerQueryClass))
#define IS_TRACKER_QUERY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACKER_QUERY))
#define IS_TRACKER_QUERY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACKER_QUERY))
#define TRACKER_QUERY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACKER_QUERY, TrackerQueryClass))

typedef struct _TrackerQuery TrackerQuery;
typedef struct _TrackerQueryClass TrackerQueryClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free_gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_gtk_tree_path_free (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	RESULT_COLUMNS_Id,
	RESULT_COLUMNS_Uri,
	RESULT_COLUMNS_Icon,
	RESULT_COLUMNS_DisplayName,
	RESULT_COLUMNS_Mime,
	RESULT_COLUMNS_Category,
	RESULT_COLUMNS_Snippet,
	RESULT_COLUMNS_IsDirectory,
	RESULT_COLUMNS_Path,
	RESULT_COLUMNS_NumOfCols
} ResultColumns;

struct _TrackerResultGrid {
	GtkScrolledWindow parent_instance;
	TrackerResultGridPrivate * priv;
	GtkListStore* store;
	GtkIconView* iconview;
};

struct _TrackerResultGridClass {
	GtkScrolledWindowClass parent_class;
};

struct _TrackerResultGridPrivate {
	TrackerQuery* _query;
};


static gpointer tracker_result_grid_parent_class = NULL;

GType result_columns_get_type (void);
GType tracker_result_grid_get_type (void);
GType tracker_query_get_type (void);
#define TRACKER_RESULT_GRID_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TRACKER_RESULT_GRID, TrackerResultGridPrivate))
enum  {
	TRACKER_RESULT_GRID_DUMMY_PROPERTY,
	TRACKER_RESULT_GRID_QUERY
};
static void _g_list_free_gtk_tree_path_free (GList* self);
GtkTreePath* tracker_result_grid_GetSelectedPath (TrackerResultGrid* self);
const char* tracker_result_grid_GetSelectedUri (TrackerResultGrid* self);
char** tracker_query_Search (TrackerQuery* self, int* result_length1, int* result_length2);
TrackerQuery* tracker_result_grid_get_Query (TrackerResultGrid* self);
char** tracker_query_Query (TrackerQuery* self, const char* sparql, int* result_length1, int* result_length2);
GdkPixbuf* tracker_utils_GetThemeIconPixbuf (GIcon* icon, gint size, GdkScreen* screen);
GdkPixbuf* tracker_utils_GetThumbNail (GFileInfo* info, gint thumb_size, gint icon_size, GdkScreen* screen);
GdkPixbuf* tracker_utils_GetThemePixbufByName (const char* icon_name, gint size, GdkScreen* screen);
void tracker_result_grid_RefreshQuery (TrackerResultGrid* self);
gboolean tracker_utils_LaunchApp (const char* uri);
gboolean tracker_utils_OpenUri (const char* uri, gboolean is_dir);
void tracker_result_grid_ActivateUri (TrackerResultGrid* self, GtkTreePath* path);
TrackerResultGrid* tracker_result_grid_new (void);
TrackerResultGrid* tracker_result_grid_construct (GType object_type);
static void _lambda2_ (TrackerResultGrid* self);
static void __lambda2__tracker_query_search_settings_changed (TrackerQuery* _sender, gpointer self);
static void _lambda3_ (TrackerResultGrid* self);
static void __lambda3__tracker_query_clear_search_results (TrackerQuery* _sender, gpointer self);
void tracker_result_grid_set_Query (TrackerResultGrid* self, TrackerQuery* value);
static void _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated (GtkIconView* _sender, GtkTreePath* path, gpointer self);
static void _lambda4_ (TrackerResultGrid* self);
static void __lambda4__gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self);
static void _lambda5_ (GdkDragContext* context, GtkSelectionData* data, guint info, guint time, TrackerResultGrid* self);
static void __lambda5__gtk_widget_drag_data_get (GtkIconView* _sender, GdkDragContext* context, GtkSelectionData* selection_data, guint info, guint time_, gpointer self);
static GObject * tracker_result_grid_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void tracker_result_grid_finalize (GObject* obj);
static void tracker_result_grid_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void tracker_result_grid_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

const GtkTargetEntry targets[3] = {{"text/uri-list", (guint) 0, (guint) 1}, {"text/plain", (guint) 0, (guint) 0}, {"STRING", (guint) 0, (guint) 0}};

static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

GType result_columns_get_type (void) {
	static volatile gsize result_columns_type_id__volatile = 0;
	if (g_once_init_enter (&result_columns_type_id__volatile)) {
		static const GEnumValue values[] = {{RESULT_COLUMNS_Id, "RESULT_COLUMNS_Id", "id"}, {RESULT_COLUMNS_Uri, "RESULT_COLUMNS_Uri", "uri"}, {RESULT_COLUMNS_Icon, "RESULT_COLUMNS_Icon", "icon"}, {RESULT_COLUMNS_DisplayName, "RESULT_COLUMNS_DisplayName", "displayname"}, {RESULT_COLUMNS_Mime, "RESULT_COLUMNS_Mime", "mime"}, {RESULT_COLUMNS_Category, "RESULT_COLUMNS_Category", "category"}, {RESULT_COLUMNS_Snippet, "RESULT_COLUMNS_Snippet", "snippet"}, {RESULT_COLUMNS_IsDirectory, "RESULT_COLUMNS_IsDirectory", "isdirectory"}, {RESULT_COLUMNS_Path, "RESULT_COLUMNS_Path", "path"}, {RESULT_COLUMNS_NumOfCols, "RESULT_COLUMNS_NumOfCols", "numofcols"}, {0, NULL, NULL}};
		GType result_columns_type_id;
		result_columns_type_id = g_enum_register_static ("ResultColumns", values);
		g_once_init_leave (&result_columns_type_id__volatile, result_columns_type_id);
	}
	return result_columns_type_id__volatile;
}


static void _g_list_free_gtk_tree_path_free (GList* self) {
	g_list_foreach (self, (GFunc) gtk_tree_path_free, NULL);
	g_list_free (self);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


#line 62 "tracker-result-grid.gs"
GtkTreePath* tracker_result_grid_GetSelectedPath (TrackerResultGrid* self) {
#line 145 "tracker-result-grid.c"
	GtkTreePath* result = NULL;
	GList* _tmp0_;
	gboolean _tmp1_;
#line 62 "tracker-result-grid.gs"
	g_return_val_if_fail (self != NULL, NULL);
#line 63 "tracker-result-grid.gs"
	if ((_tmp1_ = (_tmp0_ = gtk_icon_view_get_selected_items (self->iconview)) != NULL, __g_list_free_gtk_tree_path_free0 (_tmp0_), _tmp1_)) {
#line 153 "tracker-result-grid.c"
		GList* _tmp2_;
		GtkTreePath* _tmp3_;
		result = (_tmp3_ = _gtk_tree_path_copy0 ((GtkTreePath*) ((GtkTreePath*) (_tmp2_ = gtk_icon_view_get_selected_items (self->iconview))->data)), __g_list_free_gtk_tree_path_free0 (_tmp2_), _tmp3_);
#line 64 "tracker-result-grid.gs"
		return result;
#line 159 "tracker-result-grid.c"
	}
	result = NULL;
#line 66 "tracker-result-grid.gs"
	return result;
#line 164 "tracker-result-grid.c"
}


#line 69 "tracker-result-grid.gs"
const char* tracker_result_grid_GetSelectedUri (TrackerResultGrid* self) {
#line 170 "tracker-result-grid.c"
	const char* result = NULL;
	GtkTreeIter iter = {0};
	const char* uri;
	GtkTreePath* path;
#line 69 "tracker-result-grid.gs"
	g_return_val_if_fail (self != NULL, NULL);
#line 177 "tracker-result-grid.c"
	uri = NULL;
#line 73 "tracker-result-grid.gs"
	path = tracker_result_grid_GetSelectedPath (self);
#line 74 "tracker-result-grid.gs"
	if (path != NULL) {
#line 75 "tracker-result-grid.gs"
		gtk_tree_model_get_iter ((GtkTreeModel*) self->store, &iter, path);
#line 76 "tracker-result-grid.gs"
		gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_Uri, &uri, -1);
#line 187 "tracker-result-grid.c"
		result = uri;
		_gtk_tree_path_free0 (path);
#line 77 "tracker-result-grid.gs"
		return result;
#line 192 "tracker-result-grid.c"
	}
	result = "";
	_gtk_tree_path_free0 (path);
#line 79 "tracker-result-grid.gs"
	return result;
#line 198 "tracker-result-grid.c"
}


#line 1140 "glib-2.0.vapi"
static gboolean string_contains (const char* self, const char* needle) {
#line 204 "tracker-result-grid.c"
	gboolean result = FALSE;
#line 1140 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, FALSE);
#line 1140 "glib-2.0.vapi"
	g_return_val_if_fail (needle != NULL, FALSE);
#line 210 "tracker-result-grid.c"
	result = strstr (self, needle) != NULL;
#line 1141 "glib-2.0.vapi"
	return result;
#line 214 "tracker-result-grid.c"
}


#line 118 "tracker-result-grid.gs"
void tracker_result_grid_RefreshQuery (TrackerResultGrid* self) {
#line 220 "tracker-result-grid.c"
	GError * _inner_error_;
#line 118 "tracker-result-grid.gs"
	g_return_if_fail (self != NULL);
#line 224 "tracker-result-grid.c"
	_inner_error_ = NULL;
#line 119 "tracker-result-grid.gs"
	if (self->priv->_query != NULL) {
#line 228 "tracker-result-grid.c"
		char** _tmp2_;
		gint results_length2;
		gint results_length1;
		gint _tmp1_;
		gint _tmp0_;
		char** results;
		gboolean has_results;
		GtkTreeIter iter = {0};
		gint i;
		results = (_tmp2_ = tracker_query_Search (self->priv->_query, &_tmp0_, &_tmp1_), results_length1 = _tmp0_, results_length2 = _tmp1_, _tmp2_);
#line 121 "tracker-result-grid.gs"
		has_results = FALSE;
#line 124 "tracker-result-grid.gs"
		gtk_list_store_clear (self->store);
#line 126 "tracker-result-grid.gs"
		if (results == NULL) {
#line 245 "tracker-result-grid.c"
			results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
#line 126 "tracker-result-grid.gs"
			return;
#line 249 "tracker-result-grid.c"
		}
#line 128 "tracker-result-grid.gs"
		i = 0;
#line 129 "tracker-result-grid.gs"
		while (TRUE) {
#line 255 "tracker-result-grid.c"
			char* uri;
			char* id;
			char* mime;
#line 129 "tracker-result-grid.gs"
			if (!(results[i] != NULL)) {
#line 129 "tracker-result-grid.gs"
				break;
#line 263 "tracker-result-grid.c"
			}
#line 130 "tracker-result-grid.gs"
			uri = g_strdup (results[i + 1]);
#line 131 "tracker-result-grid.gs"
			id = g_strdup (results[i]);
#line 132 "tracker-result-grid.gs"
			mime = g_strdup (results[i + 2]);
#line 133 "tracker-result-grid.gs"
			i = i + 3;
#line 137 "tracker-result-grid.gs"
			if (g_str_has_prefix (uri, "file://")) {
#line 275 "tracker-result-grid.c"
				gboolean handled;
				GFile* file;
				char* query;
				char** _tmp5_;
				gint qresults_length2;
				gint qresults_length1;
				gint _tmp4_;
				gint _tmp3_;
				char** qresults;
				gboolean _tmp6_ = FALSE;
#line 139 "tracker-result-grid.gs"
				has_results = TRUE;
#line 140 "tracker-result-grid.gs"
				handled = FALSE;
#line 142 "tracker-result-grid.gs"
				file = g_file_new_for_uri (uri);
#line 144 "tracker-result-grid.gs"
				query = g_strdup_printf ("SELECT rdf:type(?s) where { ?s nie:url \"%s\" }", uri);
#line 294 "tracker-result-grid.c"
				qresults = (_tmp5_ = tracker_query_Query (tracker_result_grid_get_Query (self), query, &_tmp3_, &_tmp4_), qresults_length1 = _tmp3_, qresults_length2 = _tmp4_, _tmp5_);
#line 147 "tracker-result-grid.gs"
				if (qresults != NULL) {
#line 147 "tracker-result-grid.gs"
					_tmp6_ = string_contains (qresults[0], "nfo#Software");
#line 300 "tracker-result-grid.c"
				} else {
#line 147 "tracker-result-grid.gs"
					_tmp6_ = FALSE;
#line 304 "tracker-result-grid.c"
				}
#line 147 "tracker-result-grid.gs"
				if (_tmp6_) {
#line 308 "tracker-result-grid.c"
					GAppInfo* app_info;
					GAppInfo* _tmp8_;
					char* _tmp7_;
					app_info = NULL;
#line 149 "tracker-result-grid.gs"
					app_info = (_tmp8_ = (GAppInfo*) g_desktop_app_info_new_from_filename (_tmp7_ = g_file_get_path (file)), _g_object_unref0 (app_info), _tmp8_);
#line 315 "tracker-result-grid.c"
					_g_free0 (_tmp7_);
#line 151 "tracker-result-grid.gs"
					if (app_info != NULL) {
#line 319 "tracker-result-grid.c"
						GdkPixbuf* _tmp9_;
#line 152 "tracker-result-grid.gs"
						gtk_list_store_append (self->store, &iter);
#line 153 "tracker-result-grid.gs"
						gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp9_ = tracker_utils_GetThemeIconPixbuf (g_app_info_get_icon (app_info), 48, gtk_widget_get_screen ((GtkWidget*) self)), RESULT_COLUMNS_DisplayName, g_app_info_get_display_name (app_info), RESULT_COLUMNS_IsDirectory, FALSE, -1, -1);
#line 325 "tracker-result-grid.c"
						_g_object_unref0 (_tmp9_);
#line 156 "tracker-result-grid.gs"
						handled = TRUE;
#line 329 "tracker-result-grid.c"
					}
					_g_object_unref0 (app_info);
				}
#line 158 "tracker-result-grid.gs"
				if (!handled) {
#line 335 "tracker-result-grid.c"
					{
						GFileInfo* info;
						GFileType filetype;
						GdkPixbuf* _tmp10_;
#line 160 "tracker-result-grid.gs"
						info = g_file_query_info (file, "standard::display-name,standard::icon,thumbnail::path", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
#line 342 "tracker-result-grid.c"
						if (_inner_error_ != NULL) {
							goto __catch3_g_error;
						}
#line 163 "tracker-result-grid.gs"
						filetype = g_file_info_get_file_type (info);
#line 164 "tracker-result-grid.gs"
						gtk_list_store_append (self->store, &iter);
#line 165 "tracker-result-grid.gs"
						gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp10_ = tracker_utils_GetThumbNail (info, 64, 48, gtk_widget_get_screen ((GtkWidget*) self)), RESULT_COLUMNS_DisplayName, g_file_info_get_display_name (info), RESULT_COLUMNS_IsDirectory, filetype == G_FILE_TYPE_DIRECTORY, -1, -1);
#line 352 "tracker-result-grid.c"
						_g_object_unref0 (_tmp10_);
						_g_object_unref0 (info);
					}
					goto __finally3;
					__catch3_g_error:
					{
						GError * e;
						e = _inner_error_;
						_inner_error_ = NULL;
						{
#line 170 "tracker-result-grid.gs"
							g_print ("Could not get file info for %s\n", uri);
#line 365 "tracker-result-grid.c"
							_g_error_free0 (e);
						}
					}
					__finally3:
					if (_inner_error_ != NULL) {
						_g_object_unref0 (file);
						_g_free0 (query);
						qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
						_g_free0 (uri);
						_g_free0 (id);
						_g_free0 (mime);
						results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				_g_object_unref0 (file);
				_g_free0 (query);
				qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
			} else {
#line 173 "tracker-result-grid.gs"
				if (g_str_has_prefix (uri, "email://")) {
#line 389 "tracker-result-grid.c"
					char* query;
					char** _tmp13_;
					gint qresults_length2;
					gint qresults_length1;
					gint _tmp12_;
					gint _tmp11_;
					char** qresults;
					GdkPixbuf* _tmp14_;
#line 175 "tracker-result-grid.gs"
					query = g_strdup_printf ("SELECT nmo:messageSubject(?s) where { ?s nie:url \"%s\" }", uri);
#line 400 "tracker-result-grid.c"
					qresults = (_tmp13_ = tracker_query_Query (tracker_result_grid_get_Query (self), query, &_tmp11_, &_tmp12_), qresults_length1 = _tmp11_, qresults_length2 = _tmp12_, _tmp13_);
#line 178 "tracker-result-grid.gs"
					gtk_list_store_append (self->store, &iter);
#line 179 "tracker-result-grid.gs"
					gtk_list_store_set (self->store, &iter, RESULT_COLUMNS_Id, id, RESULT_COLUMNS_Uri, uri, RESULT_COLUMNS_Mime, mime, RESULT_COLUMNS_Icon, _tmp14_ = tracker_utils_GetThemePixbufByName ("evolution-mail", 48, gtk_widget_get_screen ((GtkWidget*) self)), RESULT_COLUMNS_DisplayName, qresults[0], RESULT_COLUMNS_IsDirectory, FALSE, -1, -1);
#line 406 "tracker-result-grid.c"
					_g_object_unref0 (_tmp14_);
					_g_free0 (query);
					qresults = (_vala_array_free (qresults, qresults_length1 * qresults_length2, (GDestroyNotify) g_free), NULL);
				}
			}
			_g_free0 (uri);
			_g_free0 (id);
			_g_free0 (mime);
		}
#line 184 "tracker-result-grid.gs"
		if (has_results) {
#line 418 "tracker-result-grid.c"
			GtkTreePath* path;
#line 185 "tracker-result-grid.gs"
			path = gtk_tree_path_new_from_string ("0:0:0");
#line 186 "tracker-result-grid.gs"
			if (path != NULL) {
#line 187 "tracker-result-grid.gs"
				gtk_icon_view_select_path (self->iconview, path);
#line 426 "tracker-result-grid.c"
			}
			_gtk_tree_path_free0 (path);
		}
		results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
	}
}


#line 192 "tracker-result-grid.gs"
void tracker_result_grid_ActivateUri (TrackerResultGrid* self, GtkTreePath* path) {
#line 437 "tracker-result-grid.c"
	GtkTreeIter iter = {0};
	gboolean is_dir;
	const char* uri;
	char* query;
	char** _tmp2_;
	gint results_length2;
	gint results_length1;
	gint _tmp1_;
	gint _tmp0_;
	char** results;
	gboolean _tmp3_ = FALSE;
#line 192 "tracker-result-grid.gs"
	g_return_if_fail (self != NULL);
#line 192 "tracker-result-grid.gs"
	g_return_if_fail (path != NULL);
#line 194 "tracker-result-grid.gs"
	is_dir = FALSE;
#line 196 "tracker-result-grid.gs"
	gtk_tree_model_get_iter ((GtkTreeModel*) self->store, &iter, path);
#line 457 "tracker-result-grid.c"
	uri = NULL;
#line 198 "tracker-result-grid.gs"
	gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_Uri, &uri, -1);
#line 199 "tracker-result-grid.gs"
	gtk_tree_model_get ((GtkTreeModel*) self->store, &iter, RESULT_COLUMNS_IsDirectory, &is_dir, -1);
#line 201 "tracker-result-grid.gs"
	query = g_strdup_printf ("SELECT rdf:type(?s) where { ?s nie:url \"%s\" }", uri);
#line 465 "tracker-result-grid.c"
	results = (_tmp2_ = tracker_query_Query (tracker_result_grid_get_Query (self), query, &_tmp0_, &_tmp1_), results_length1 = _tmp0_, results_length2 = _tmp1_, _tmp2_);
#line 203 "tracker-result-grid.gs"
	if (results != NULL) {
#line 203 "tracker-result-grid.gs"
		_tmp3_ = string_contains (results[0], "nfo#Software");
#line 471 "tracker-result-grid.c"
	} else {
#line 203 "tracker-result-grid.gs"
		_tmp3_ = FALSE;
#line 475 "tracker-result-grid.c"
	}
#line 203 "tracker-result-grid.gs"
	if (_tmp3_) {
#line 204 "tracker-result-grid.gs"
		tracker_utils_LaunchApp (uri);
#line 481 "tracker-result-grid.c"
	} else {
#line 206 "tracker-result-grid.gs"
		tracker_utils_OpenUri (uri, is_dir);
#line 485 "tracker-result-grid.c"
	}
	_g_free0 (query);
	results = (_vala_array_free (results, results_length1 * results_length2, (GDestroyNotify) g_free), NULL);
}


#line 44 "tracker-result-grid.gs"
TrackerResultGrid* tracker_result_grid_construct (GType object_type) {
#line 494 "tracker-result-grid.c"
	TrackerResultGrid * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


#line 44 "tracker-result-grid.gs"
TrackerResultGrid* tracker_result_grid_new (void) {
#line 44 "tracker-result-grid.gs"
	return tracker_result_grid_construct (TYPE_TRACKER_RESULT_GRID);
#line 505 "tracker-result-grid.c"
}


TrackerQuery* tracker_result_grid_get_Query (TrackerResultGrid* self) {
	TrackerQuery* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_query;
#line 53 "tracker-result-grid.gs"
	return result;
#line 515 "tracker-result-grid.c"
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 57 "tracker-result-grid.gs"
static void _lambda2_ (TrackerResultGrid* self) {
#line 58 "tracker-result-grid.gs"
	tracker_result_grid_RefreshQuery (self);
#line 528 "tracker-result-grid.c"
}


#line 57 "tracker-result-grid.gs"
static void __lambda2__tracker_query_search_settings_changed (TrackerQuery* _sender, gpointer self) {
#line 534 "tracker-result-grid.c"
	_lambda2_ (self);
}


#line 59 "tracker-result-grid.gs"
static void _lambda3_ (TrackerResultGrid* self) {
#line 60 "tracker-result-grid.gs"
	gtk_list_store_clear (self->store);
#line 543 "tracker-result-grid.c"
}


#line 59 "tracker-result-grid.gs"
static void __lambda3__tracker_query_clear_search_results (TrackerQuery* _sender, gpointer self) {
#line 549 "tracker-result-grid.c"
	_lambda3_ (self);
}


void tracker_result_grid_set_Query (TrackerResultGrid* self, TrackerQuery* value) {
	g_return_if_fail (self != NULL);
#line 55 "tracker-result-grid.gs"
	if (value != NULL) {
#line 558 "tracker-result-grid.c"
		TrackerQuery* _tmp0_;
#line 56 "tracker-result-grid.gs"
		self->priv->_query = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_query), _tmp0_);
#line 57 "tracker-result-grid.gs"
		g_signal_connect_object (self->priv->_query, "search-settings-changed", (GCallback) __lambda2__tracker_query_search_settings_changed, self, 0);
#line 59 "tracker-result-grid.gs"
		g_signal_connect_object (self->priv->_query, "clear-search-results", (GCallback) __lambda3__tracker_query_clear_search_results, self, 0);
#line 566 "tracker-result-grid.c"
	}
	g_object_notify ((GObject *) self, "Query");
}


#line 192 "tracker-result-grid.gs"
static void _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated (GtkIconView* _sender, GtkTreePath* path, gpointer self) {
#line 574 "tracker-result-grid.c"
	tracker_result_grid_ActivateUri (self, path);
}


#line 102 "tracker-result-grid.gs"
static void _lambda4_ (TrackerResultGrid* self) {
#line 581 "tracker-result-grid.c"
	GtkTreePath* path;
#line 103 "tracker-result-grid.gs"
	path = tracker_result_grid_GetSelectedPath (self);
#line 104 "tracker-result-grid.gs"
	g_signal_emit_by_name (self, "selection-changed", path);
#line 587 "tracker-result-grid.c"
	_gtk_tree_path_free0 (path);
}


#line 102 "tracker-result-grid.gs"
static void __lambda4__gtk_icon_view_selection_changed (GtkIconView* _sender, gpointer self) {
#line 594 "tracker-result-grid.c"
	_lambda4_ (self);
}


#line 107 "tracker-result-grid.gs"
static void _lambda5_ (GdkDragContext* context, GtkSelectionData* data, guint info, guint time, TrackerResultGrid* self) {
#line 601 "tracker-result-grid.c"
	char* uri;
#line 107 "tracker-result-grid.gs"
	g_return_if_fail (context != NULL);
#line 107 "tracker-result-grid.gs"
	g_return_if_fail (data != NULL);
#line 108 "tracker-result-grid.gs"
	uri = g_strdup (tracker_result_grid_GetSelectedUri (self));
#line 109 "tracker-result-grid.gs"
	if (uri != NULL) {
#line 611 "tracker-result-grid.c"
		char** _tmp0_;
		gint _s_size_;
		gint s_length1;
		char** s;
		char* _tmp1_;
		s = (_tmp0_ = g_new0 (char*, 1 + 1), s_length1 = 1, _s_size_ = s_length1, _tmp0_);
#line 111 "tracker-result-grid.gs"
		s[0] = (_tmp1_ = g_strdup (uri), _g_free0 (s[0]), _tmp1_);
#line 112 "tracker-result-grid.gs"
		gtk_selection_data_set_uris (data, s);
#line 622 "tracker-result-grid.c"
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_free0 (uri);
}


#line 107 "tracker-result-grid.gs"
static void __lambda5__gtk_widget_drag_data_get (GtkIconView* _sender, GdkDragContext* context, GtkSelectionData* selection_data, guint info, guint time_, gpointer self) {
#line 631 "tracker-result-grid.c"
	_lambda5_ (context, selection_data, info, time_, self);
}


static GObject * tracker_result_grid_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	TrackerResultGrid * self;
	parent_class = G_OBJECT_CLASS (tracker_result_grid_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = TRACKER_RESULT_GRID (obj);
	{
		GtkListStore* _tmp0_;
		GtkIconView* _tmp1_;
#line 84 "tracker-result-grid.gs"
		g_object_set ((GtkScrolledWindow*) self, "hscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
#line 85 "tracker-result-grid.gs"
		g_object_set ((GtkScrolledWindow*) self, "vscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
#line 86 "tracker-result-grid.gs"
		gtk_scrolled_window_set_shadow_type ((GtkScrolledWindow*) self, GTK_SHADOW_ETCHED_OUT);
#line 88 "tracker-result-grid.gs"
		self->store = (_tmp0_ = gtk_list_store_new ((gint) RESULT_COLUMNS_NumOfCols, G_TYPE_STRING, G_TYPE_STRING, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_STRING, NULL), _g_object_unref0 (self->store), _tmp0_);
#line 93 "tracker-result-grid.gs"
		self->iconview = (_tmp1_ = g_object_ref_sink ((GtkIconView*) gtk_icon_view_new_with_model ((GtkTreeModel*) self->store)), _g_object_unref0 (self->iconview), _tmp1_);
#line 94 "tracker-result-grid.gs"
		gtk_icon_view_set_pixbuf_column (self->iconview, (gint) RESULT_COLUMNS_Icon);
#line 95 "tracker-result-grid.gs"
		gtk_icon_view_set_text_column (self->iconview, (gint) RESULT_COLUMNS_DisplayName);
#line 96 "tracker-result-grid.gs"
		gtk_icon_view_set_selection_mode (self->iconview, GTK_SELECTION_BROWSE);
#line 97 "tracker-result-grid.gs"
		gtk_icon_view_enable_model_drag_source (self->iconview, GDK_BUTTON1_MASK | GDK_BUTTON2_MASK, targets, G_N_ELEMENTS (targets), (GDK_ACTION_COPY | GDK_ACTION_MOVE) | GDK_ACTION_ASK);
#line 98 "tracker-result-grid.gs"
		gtk_icon_view_set_item_width (self->iconview, 150);
#line 99 "tracker-result-grid.gs"
		gtk_icon_view_set_row_spacing (self->iconview, 10);
#line 100 "tracker-result-grid.gs"
		g_signal_connect_object (self->iconview, "item-activated", (GCallback) _tracker_result_grid_ActivateUri_gtk_icon_view_item_activated, self, 0);
#line 102 "tracker-result-grid.gs"
		g_signal_connect_object (self->iconview, "selection-changed", (GCallback) __lambda4__gtk_icon_view_selection_changed, self, 0);
#line 107 "tracker-result-grid.gs"
		g_signal_connect_object ((GtkWidget*) self->iconview, "drag-data-get", (GCallback) __lambda5__gtk_widget_drag_data_get, self, 0);
#line 114 "tracker-result-grid.gs"
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->iconview);
#line 115 "tracker-result-grid.gs"
		gtk_widget_show_all ((GtkWidget*) self);
#line 678 "tracker-result-grid.c"
	}
	return obj;
}


static void tracker_result_grid_class_init (TrackerResultGridClass * klass) {
	tracker_result_grid_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TrackerResultGridPrivate));
	G_OBJECT_CLASS (klass)->get_property = tracker_result_grid_get_property;
	G_OBJECT_CLASS (klass)->set_property = tracker_result_grid_set_property;
	G_OBJECT_CLASS (klass)->constructor = tracker_result_grid_constructor;
	G_OBJECT_CLASS (klass)->finalize = tracker_result_grid_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_RESULT_GRID_QUERY, g_param_spec_object ("Query", "Query", "Query", TYPE_TRACKER_QUERY, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("selection_changed", TYPE_TRACKER_RESULT_GRID, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, GTK_TYPE_TREE_PATH);
}


static void tracker_result_grid_instance_init (TrackerResultGrid * self) {
	self->priv = TRACKER_RESULT_GRID_GET_PRIVATE (self);
}


static void tracker_result_grid_finalize (GObject* obj) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (obj);
	_g_object_unref0 (self->store);
	_g_object_unref0 (self->iconview);
	_g_object_unref0 (self->priv->_query);
	G_OBJECT_CLASS (tracker_result_grid_parent_class)->finalize (obj);
}


GType tracker_result_grid_get_type (void) {
	static volatile gsize tracker_result_grid_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_result_grid_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TrackerResultGridClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tracker_result_grid_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TrackerResultGrid), 0, (GInstanceInitFunc) tracker_result_grid_instance_init, NULL };
		GType tracker_result_grid_type_id;
		tracker_result_grid_type_id = g_type_register_static (GTK_TYPE_SCROLLED_WINDOW, "TrackerResultGrid", &g_define_type_info, 0);
		g_once_init_leave (&tracker_result_grid_type_id__volatile, tracker_result_grid_type_id);
	}
	return tracker_result_grid_type_id__volatile;
}


static void tracker_result_grid_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (object);
	switch (property_id) {
		case TRACKER_RESULT_GRID_QUERY:
		g_value_set_object (value, tracker_result_grid_get_Query (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void tracker_result_grid_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	TrackerResultGrid * self;
	self = TRACKER_RESULT_GRID (object);
	switch (property_id) {
		case TRACKER_RESULT_GRID_QUERY:
		tracker_result_grid_set_Query (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__BOXED callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_boxed (param_values + 1), data2);
}



