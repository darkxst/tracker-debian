/* tracker-turtle-reader.c generated by valac 0.12.0, the Vala compiler
 * generated from tracker-turtle-reader.vala, do not modify */

/*
 * Copyright (C) 2009, Nokia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libtracker-sparql/tracker-sparql.h>
#include <libtracker-common/tracker-date-time.h>
#include <libtracker-data/tracker-db-interface.h>
#include <libtracker-data/tracker-data-query.h>
#include <libtracker-data/tracker-data-update.h>
#include <libtracker-data/tracker-data-backup.h>


#define TRACKER_TYPE_TURTLE_READER (tracker_turtle_reader_get_type ())
#define TRACKER_TURTLE_READER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TRACKER_TYPE_TURTLE_READER, TrackerTurtleReader))
#define TRACKER_TURTLE_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TRACKER_TYPE_TURTLE_READER, TrackerTurtleReaderClass))
#define TRACKER_IS_TURTLE_READER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TRACKER_TYPE_TURTLE_READER))
#define TRACKER_IS_TURTLE_READER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TRACKER_TYPE_TURTLE_READER))
#define TRACKER_TURTLE_READER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TRACKER_TYPE_TURTLE_READER, TrackerTurtleReaderClass))

typedef struct _TrackerTurtleReader TrackerTurtleReader;
typedef struct _TrackerTurtleReaderClass TrackerTurtleReaderClass;
typedef struct _TrackerTurtleReaderPrivate TrackerTurtleReaderPrivate;

#define TRACKER_TYPE_SPARQL_SCANNER (tracker_sparql_scanner_get_type ())
#define TRACKER_SPARQL_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TRACKER_TYPE_SPARQL_SCANNER, TrackerSparqlScanner))
#define TRACKER_SPARQL_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TRACKER_TYPE_SPARQL_SCANNER, TrackerSparqlScannerClass))
#define TRACKER_IS_SPARQL_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TRACKER_TYPE_SPARQL_SCANNER))
#define TRACKER_IS_SPARQL_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TRACKER_TYPE_SPARQL_SCANNER))
#define TRACKER_SPARQL_SCANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TRACKER_TYPE_SPARQL_SCANNER, TrackerSparqlScannerClass))

typedef struct _TrackerSparqlScanner TrackerSparqlScanner;
typedef struct _TrackerSparqlScannerClass TrackerSparqlScannerClass;

#define TRACKER_TURTLE_READER_TYPE_TOKEN_INFO (tracker_turtle_reader_token_info_get_type ())

#define TRACKER_TYPE_SPARQL_TOKEN_TYPE (tracker_sparql_token_type_get_type ())

#define TRACKER_TYPE_SOURCE_LOCATION (tracker_source_location_get_type ())
typedef struct _TrackerSourceLocation TrackerSourceLocation;
typedef struct _TrackerTurtleReaderTokenInfo TrackerTurtleReaderTokenInfo;

#define TRACKER_TURTLE_READER_TYPE_STATE (tracker_turtle_reader_state_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_mapped_file_unref0(var) ((var == NULL) ? NULL : (var = (g_mapped_file_unref (var), NULL)))
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _TrackerTurtleReader {
	GObject parent_instance;
	TrackerTurtleReaderPrivate * priv;
};

struct _TrackerTurtleReaderClass {
	GObjectClass parent_class;
};

typedef enum  {
	TRACKER_SPARQL_TOKEN_TYPE_NONE,
	TRACKER_SPARQL_TOKEN_TYPE_A,
	TRACKER_SPARQL_TOKEN_TYPE_AS,
	TRACKER_SPARQL_TOKEN_TYPE_ASC,
	TRACKER_SPARQL_TOKEN_TYPE_ASK,
	TRACKER_SPARQL_TOKEN_TYPE_ATBASE,
	TRACKER_SPARQL_TOKEN_TYPE_ATPREFIX,
	TRACKER_SPARQL_TOKEN_TYPE_AVG,
	TRACKER_SPARQL_TOKEN_TYPE_BASE,
	TRACKER_SPARQL_TOKEN_TYPE_BLANK_NODE,
	TRACKER_SPARQL_TOKEN_TYPE_BOUND,
	TRACKER_SPARQL_TOKEN_TYPE_BY,
	TRACKER_SPARQL_TOKEN_TYPE_CLOSE_BRACE,
	TRACKER_SPARQL_TOKEN_TYPE_CLOSE_BRACKET,
	TRACKER_SPARQL_TOKEN_TYPE_CLOSE_PARENS,
	TRACKER_SPARQL_TOKEN_TYPE_COALESCE,
	TRACKER_SPARQL_TOKEN_TYPE_COLON,
	TRACKER_SPARQL_TOKEN_TYPE_COMMA,
	TRACKER_SPARQL_TOKEN_TYPE_CONSTRUCT,
	TRACKER_SPARQL_TOKEN_TYPE_COUNT,
	TRACKER_SPARQL_TOKEN_TYPE_DATA,
	TRACKER_SPARQL_TOKEN_TYPE_DATATYPE,
	TRACKER_SPARQL_TOKEN_TYPE_DECIMAL,
	TRACKER_SPARQL_TOKEN_TYPE_DELETE,
	TRACKER_SPARQL_TOKEN_TYPE_DESC,
	TRACKER_SPARQL_TOKEN_TYPE_DESCRIBE,
	TRACKER_SPARQL_TOKEN_TYPE_DISTINCT,
	TRACKER_SPARQL_TOKEN_TYPE_DIV,
	TRACKER_SPARQL_TOKEN_TYPE_DOT,
	TRACKER_SPARQL_TOKEN_TYPE_DOUBLE,
	TRACKER_SPARQL_TOKEN_TYPE_DOUBLE_CIRCUMFLEX,
	TRACKER_SPARQL_TOKEN_TYPE_DROP,
	TRACKER_SPARQL_TOKEN_TYPE_EOF,
	TRACKER_SPARQL_TOKEN_TYPE_EXISTS,
	TRACKER_SPARQL_TOKEN_TYPE_FALSE,
	TRACKER_SPARQL_TOKEN_TYPE_FILTER,
	TRACKER_SPARQL_TOKEN_TYPE_FROM,
	TRACKER_SPARQL_TOKEN_TYPE_GRAPH,
	TRACKER_SPARQL_TOKEN_TYPE_GROUP,
	TRACKER_SPARQL_TOKEN_TYPE_GROUP_CONCAT,
	TRACKER_SPARQL_TOKEN_TYPE_HAVING,
	TRACKER_SPARQL_TOKEN_TYPE_IF,
	TRACKER_SPARQL_TOKEN_TYPE_INSERT,
	TRACKER_SPARQL_TOKEN_TYPE_INTEGER,
	TRACKER_SPARQL_TOKEN_TYPE_INTO,
	TRACKER_SPARQL_TOKEN_TYPE_IRI_REF,
	TRACKER_SPARQL_TOKEN_TYPE_ISBLANK,
	TRACKER_SPARQL_TOKEN_TYPE_ISIRI,
	TRACKER_SPARQL_TOKEN_TYPE_ISLITERAL,
	TRACKER_SPARQL_TOKEN_TYPE_ISURI,
	TRACKER_SPARQL_TOKEN_TYPE_LANG,
	TRACKER_SPARQL_TOKEN_TYPE_LANGMATCHES,
	TRACKER_SPARQL_TOKEN_TYPE_LIMIT,
	TRACKER_SPARQL_TOKEN_TYPE_MAX,
	TRACKER_SPARQL_TOKEN_TYPE_MIN,
	TRACKER_SPARQL_TOKEN_TYPE_MINUS,
	TRACKER_SPARQL_TOKEN_TYPE_NAMED,
	TRACKER_SPARQL_TOKEN_TYPE_NOT,
	TRACKER_SPARQL_TOKEN_TYPE_OFFSET,
	TRACKER_SPARQL_TOKEN_TYPE_OP_AND,
	TRACKER_SPARQL_TOKEN_TYPE_OP_EQ,
	TRACKER_SPARQL_TOKEN_TYPE_OP_GE,
	TRACKER_SPARQL_TOKEN_TYPE_OP_GT,
	TRACKER_SPARQL_TOKEN_TYPE_OP_LE,
	TRACKER_SPARQL_TOKEN_TYPE_OP_LT,
	TRACKER_SPARQL_TOKEN_TYPE_OP_NE,
	TRACKER_SPARQL_TOKEN_TYPE_OP_NEG,
	TRACKER_SPARQL_TOKEN_TYPE_OP_OR,
	TRACKER_SPARQL_TOKEN_TYPE_OP_IN,
	TRACKER_SPARQL_TOKEN_TYPE_OPEN_BRACE,
	TRACKER_SPARQL_TOKEN_TYPE_OPEN_BRACKET,
	TRACKER_SPARQL_TOKEN_TYPE_OPEN_PARENS,
	TRACKER_SPARQL_TOKEN_TYPE_OPTIONAL,
	TRACKER_SPARQL_TOKEN_TYPE_OR,
	TRACKER_SPARQL_TOKEN_TYPE_ORDER,
	TRACKER_SPARQL_TOKEN_TYPE_PLUS,
	TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX,
	TRACKER_SPARQL_TOKEN_TYPE_PREFIX,
	TRACKER_SPARQL_TOKEN_TYPE_REDUCED,
	TRACKER_SPARQL_TOKEN_TYPE_REGEX,
	TRACKER_SPARQL_TOKEN_TYPE_REPLACE,
	TRACKER_SPARQL_TOKEN_TYPE_SAMETERM,
	TRACKER_SPARQL_TOKEN_TYPE_SELECT,
	TRACKER_SPARQL_TOKEN_TYPE_SEMICOLON,
	TRACKER_SPARQL_TOKEN_TYPE_SILENT,
	TRACKER_SPARQL_TOKEN_TYPE_STAR,
	TRACKER_SPARQL_TOKEN_TYPE_STR,
	TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL1,
	TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL2,
	TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL_LONG1,
	TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL_LONG2,
	TRACKER_SPARQL_TOKEN_TYPE_SUM,
	TRACKER_SPARQL_TOKEN_TYPE_TRUE,
	TRACKER_SPARQL_TOKEN_TYPE_UNION,
	TRACKER_SPARQL_TOKEN_TYPE_VAR,
	TRACKER_SPARQL_TOKEN_TYPE_WHERE,
	TRACKER_SPARQL_TOKEN_TYPE_WITH
} TrackerSparqlTokenType;

struct _TrackerSourceLocation {
	gchar* pos;
	gint line;
	gint column;
};

struct _TrackerTurtleReaderTokenInfo {
	TrackerSparqlTokenType type;
	TrackerSourceLocation begin;
	TrackerSourceLocation end;
};

typedef enum  {
	TRACKER_TURTLE_READER_STATE_INITIAL,
	TRACKER_TURTLE_READER_STATE_BOS,
	TRACKER_TURTLE_READER_STATE_SUBJECT,
	TRACKER_TURTLE_READER_STATE_PREDICATE,
	TRACKER_TURTLE_READER_STATE_OBJECT
} TrackerTurtleReaderState;

struct _TrackerTurtleReaderPrivate {
	TrackerSparqlScanner* scanner;
	TrackerTurtleReaderTokenInfo* tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gint index;
	gint size;
	TrackerTurtleReaderState state;
	gchar* _graph;
	gchar* _subject;
	gchar* _predicate;
	gchar* _object;
	gboolean _object_is_uri;
	GHashTable* prefix_map;
	gchar** subject_stack;
	gint subject_stack_length1;
	gint _subject_stack_size_;
	gchar** predicate_stack;
	gint predicate_stack_length1;
	gint _predicate_stack_size_;
	gint bnodeid;
	guchar* base_uuid;
	gint base_uuid_length1;
	gint _base_uuid_size_;
	GMappedFile* mapped_file;
};


static gpointer tracker_turtle_reader_parent_class = NULL;

GType tracker_turtle_reader_get_type (void) G_GNUC_CONST;
GType tracker_sparql_scanner_get_type (void) G_GNUC_CONST;
static GType tracker_turtle_reader_token_info_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
GType tracker_sparql_token_type_get_type (void) G_GNUC_CONST;
GType tracker_source_location_get_type (void) G_GNUC_CONST;
TrackerSourceLocation* tracker_source_location_dup (const TrackerSourceLocation* self);
void tracker_source_location_free (TrackerSourceLocation* self);
static TrackerTurtleReaderTokenInfo* tracker_turtle_reader_token_info_dup (const TrackerTurtleReaderTokenInfo* self);
static void tracker_turtle_reader_token_info_free (TrackerTurtleReaderTokenInfo* self);
static GType tracker_turtle_reader_state_get_type (void) G_GNUC_UNUSED;
#define TRACKER_TURTLE_READER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TRACKER_TYPE_TURTLE_READER, TrackerTurtleReaderPrivate))
enum  {
	TRACKER_TURTLE_READER_DUMMY_PROPERTY,
	TRACKER_TURTLE_READER_GRAPH,
	TRACKER_TURTLE_READER_SUBJECT,
	TRACKER_TURTLE_READER_PREDICATE,
	TRACKER_TURTLE_READER_OBJECT,
	TRACKER_TURTLE_READER_OBJECT_IS_URI
};
#define TRACKER_TURTLE_READER_BUFFER_SIZE 32
TrackerTurtleReader* tracker_turtle_reader_new (const gchar* path, GError** error);
TrackerTurtleReader* tracker_turtle_reader_construct (GType object_type, const gchar* path, GError** error);
TrackerSparqlScanner* tracker_sparql_scanner_new (gchar* input, gsize len);
TrackerSparqlScanner* tracker_sparql_scanner_construct (GType object_type, gchar* input, gsize len);
void uuid_generate (guchar* uuid);
static gchar* tracker_turtle_reader_generate_bnodeid (TrackerTurtleReader* self, const gchar* user_bnodeid);
static inline gboolean tracker_turtle_reader_next_token (TrackerTurtleReader* self, GError** error);
TrackerSparqlTokenType tracker_sparql_scanner_read_token (TrackerSparqlScanner* self, TrackerSourceLocation* token_begin, TrackerSourceLocation* token_end, GError** error);
static inline TrackerSparqlTokenType tracker_turtle_reader_current (TrackerTurtleReader* self);
static inline gboolean tracker_turtle_reader_accept (TrackerTurtleReader* self, TrackerSparqlTokenType type, GError** error);
static GError* tracker_turtle_reader_get_error (TrackerTurtleReader* self, const gchar* msg);
static gboolean tracker_turtle_reader_expect (TrackerTurtleReader* self, TrackerSparqlTokenType type, GError** error);
const gchar* tracker_sparql_token_type_to_string (TrackerSparqlTokenType self);
static gchar* tracker_turtle_reader_get_last_string (TrackerTurtleReader* self, gint strip);
static gchar* tracker_turtle_reader_resolve_prefixed_name (TrackerTurtleReader* self, const gchar* prefix, const gchar* local_name, GError** error);
gboolean tracker_turtle_reader_next (TrackerTurtleReader* self, GError** error);
static void tracker_turtle_reader_set_subject (TrackerTurtleReader* self, const gchar* value);
static void tracker_turtle_reader_set_predicate (TrackerTurtleReader* self, const gchar* value);
static void tracker_turtle_reader_set_object (TrackerTurtleReader* self, const gchar* value);
static void tracker_turtle_reader_set_object_is_uri (TrackerTurtleReader* self, gboolean value);
const gchar* tracker_turtle_reader_get_subject (TrackerTurtleReader* self);
static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value);
const gchar* tracker_turtle_reader_get_predicate (TrackerTurtleReader* self);
static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value);
void tracker_turtle_reader_load (const gchar* path, GError** error);
gboolean tracker_turtle_reader_get_object_is_uri (TrackerTurtleReader* self);
const gchar* tracker_turtle_reader_get_graph (TrackerTurtleReader* self);
const gchar* tracker_turtle_reader_get_object (TrackerTurtleReader* self);
static void tracker_turtle_reader_set_graph (TrackerTurtleReader* self, const gchar* value);
static void tracker_turtle_reader_finalize (GObject* obj);
static void _vala_tracker_turtle_reader_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_tracker_turtle_reader_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static GType tracker_turtle_reader_state_get_type (void) {
	static volatile gsize tracker_turtle_reader_state_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_turtle_reader_state_type_id__volatile)) {
		static const GEnumValue values[] = {{TRACKER_TURTLE_READER_STATE_INITIAL, "TRACKER_TURTLE_READER_STATE_INITIAL", "initial"}, {TRACKER_TURTLE_READER_STATE_BOS, "TRACKER_TURTLE_READER_STATE_BOS", "bos"}, {TRACKER_TURTLE_READER_STATE_SUBJECT, "TRACKER_TURTLE_READER_STATE_SUBJECT", "subject"}, {TRACKER_TURTLE_READER_STATE_PREDICATE, "TRACKER_TURTLE_READER_STATE_PREDICATE", "predicate"}, {TRACKER_TURTLE_READER_STATE_OBJECT, "TRACKER_TURTLE_READER_STATE_OBJECT", "object"}, {0, NULL, NULL}};
		GType tracker_turtle_reader_state_type_id;
		tracker_turtle_reader_state_type_id = g_enum_register_static ("TrackerTurtleReaderState", values);
		g_once_init_leave (&tracker_turtle_reader_state_type_id__volatile, tracker_turtle_reader_state_type_id);
	}
	return tracker_turtle_reader_state_type_id__volatile;
}


TrackerTurtleReader* tracker_turtle_reader_construct (GType object_type, const gchar* path, GError** error) {
	TrackerTurtleReader * self = NULL;
	GMappedFile* _tmp0_ = NULL;
	GMappedFile* _tmp1_;
	gchar* _tmp2_ = NULL;
	gsize _tmp3_;
	TrackerSparqlScanner* _tmp4_ = NULL;
	guchar* _tmp5_ = NULL;
	TrackerTurtleReaderTokenInfo* _tmp6_ = NULL;
	GHashTable* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	self = (TrackerTurtleReader*) g_object_new (object_type, NULL);
	_tmp0_ = g_mapped_file_new (path, FALSE, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (self);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_g_mapped_file_unref0 (self->priv->mapped_file);
	self->priv->mapped_file = _tmp1_;
	_tmp2_ = g_mapped_file_get_contents (self->priv->mapped_file);
	_tmp3_ = g_mapped_file_get_length (self->priv->mapped_file);
	_tmp4_ = tracker_sparql_scanner_new (_tmp2_, _tmp3_);
	_g_object_unref0 (self->priv->scanner);
	self->priv->scanner = _tmp4_;
	_tmp5_ = g_new0 (guchar, 16);
	self->priv->base_uuid = (g_free (self->priv->base_uuid), NULL);
	self->priv->base_uuid = _tmp5_;
	self->priv->base_uuid_length1 = 16;
	self->priv->_base_uuid_size_ = 16;
	uuid_generate (self->priv->base_uuid);
	_tmp6_ = g_new0 (TrackerTurtleReaderTokenInfo, TRACKER_TURTLE_READER_BUFFER_SIZE);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	self->priv->tokens = _tmp6_;
	self->priv->tokens_length1 = TRACKER_TURTLE_READER_BUFFER_SIZE;
	self->priv->_tokens_size_ = TRACKER_TURTLE_READER_BUFFER_SIZE;
	_tmp7_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
	_g_hash_table_unref0 (self->priv->prefix_map);
	self->priv->prefix_map = _tmp7_;
	return self;
}


TrackerTurtleReader* tracker_turtle_reader_new (const gchar* path, GError** error) {
	return tracker_turtle_reader_construct (TRACKER_TYPE_TURTLE_READER, path, error);
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_ = NULL;
	gchar* end;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	if (end == NULL) {
		result = maxlen;
		return result;
	} else {
		result = (glong) (end - str);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= 0) {
		_tmp0_ = len >= 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp1_;
		_tmp1_ = string_strnlen ((gchar*) self, offset + len);
		string_length = _tmp1_;
	} else {
		gint _tmp2_;
		_tmp2_ = strlen (self);
		string_length = (glong) _tmp2_;
	}
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}


static gchar* tracker_turtle_reader_generate_bnodeid (TrackerTurtleReader* self, const gchar* user_bnodeid) {
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (user_bnodeid == NULL) {
		gchar* _tmp0_ = NULL;
		self->priv->bnodeid = self->priv->bnodeid + 1;
		_tmp0_ = g_strdup_printf (":%d", self->priv->bnodeid);
		result = _tmp0_;
		return result;
	} else {
		GChecksum* _tmp1_ = NULL;
		GChecksum* checksum;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* sha1;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		_tmp1_ = g_checksum_new (G_CHECKSUM_SHA1);
		checksum = _tmp1_;
		g_checksum_update (checksum, self->priv->base_uuid, (gsize) 16);
		g_checksum_update (checksum, (guchar*) user_bnodeid, (gsize) (-1));
		_tmp2_ = g_checksum_get_string (checksum);
		_tmp3_ = g_strdup (_tmp2_);
		sha1 = _tmp3_;
		_tmp4_ = string_substring (sha1, (glong) 8, (glong) (-1));
		_tmp5_ = _tmp4_;
		_tmp6_ = string_substring (sha1, (glong) 12, (glong) (-1));
		_tmp7_ = _tmp6_;
		_tmp8_ = string_substring (sha1, (glong) 16, (glong) (-1));
		_tmp9_ = _tmp8_;
		_tmp10_ = string_substring (sha1, (glong) 20, (glong) (-1));
		_tmp11_ = _tmp10_;
		_tmp12_ = g_strdup_printf ("urn:uuid:%.8s-%.4s-%.4s-%.4s-%.12s", sha1, _tmp5_, _tmp7_, _tmp9_, _tmp11_);
		_tmp13_ = _tmp12_;
		_g_free0 (_tmp11_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		result = _tmp13_;
		_g_free0 (sha1);
		_g_checksum_free0 (checksum);
		return result;
	}
}


static inline gboolean tracker_turtle_reader_next_token (TrackerTurtleReader* self, GError** error) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->index = (self->priv->index + 1) % TRACKER_TURTLE_READER_BUFFER_SIZE;
	self->priv->size--;
	if (self->priv->size <= 0) {
		TrackerSourceLocation begin = {0};
		TrackerSourceLocation end = {0};
		TrackerSourceLocation _tmp0_ = {0};
		TrackerSourceLocation _tmp1_ = {0};
		TrackerSparqlTokenType _tmp2_;
		TrackerSparqlTokenType type;
		_tmp2_ = tracker_sparql_scanner_read_token (self->priv->scanner, &_tmp0_, &_tmp1_, &_inner_error_);
		begin = _tmp0_;
		end = _tmp1_;
		type = _tmp2_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
				g_propagate_error (error, _inner_error_);
				return FALSE;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		self->priv->tokens[self->priv->index].type = type;
		self->priv->tokens[self->priv->index].begin = begin;
		self->priv->tokens[self->priv->index].end = end;
		self->priv->size = 1;
	}
	result = self->priv->tokens[self->priv->index].type != TRACKER_SPARQL_TOKEN_TYPE_EOF;
	return result;
}


static inline TrackerSparqlTokenType tracker_turtle_reader_current (TrackerTurtleReader* self) {
	TrackerSparqlTokenType result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->tokens[self->priv->index].type;
	return result;
}


static inline gboolean tracker_turtle_reader_accept (TrackerTurtleReader* self, TrackerSparqlTokenType type, GError** error) {
	gboolean result = FALSE;
	TrackerSparqlTokenType _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = tracker_turtle_reader_current (self);
	if (_tmp0_ == type) {
		tracker_turtle_reader_next_token (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
				g_propagate_error (error, _inner_error_);
				return FALSE;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static GError* tracker_turtle_reader_get_error (TrackerTurtleReader* self, const gchar* msg) {
	GError* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GError* _tmp2_ = NULL;
	GError* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (msg != NULL, NULL);
	_tmp0_ = g_strdup_printf ("%d.%d: syntax error, %s", self->priv->tokens[self->priv->index].begin.line, self->priv->tokens[self->priv->index].begin.column, msg);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_error_new_literal (TRACKER_SPARQL_ERROR, TRACKER_SPARQL_ERROR_PARSE, _tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	result = _tmp3_;
	return result;
}


static gboolean tracker_turtle_reader_expect (TrackerTurtleReader* self, TrackerSparqlTokenType type, GError** error) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	GError* _tmp5_ = NULL;
	GError* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = tracker_turtle_reader_accept (self, type, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	if (_tmp1_) {
		result = TRUE;
		return result;
	}
	_tmp2_ = tracker_sparql_token_type_to_string (type);
	_tmp3_ = g_strdup_printf ("expected %s", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = tracker_turtle_reader_get_error (self, _tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_inner_error_ = _tmp6_;
	if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
		g_propagate_error (error, _inner_error_);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
}


static gchar* tracker_turtle_reader_get_last_string (TrackerTurtleReader* self, gint strip) {
	gchar* result = NULL;
	gint last_index;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + TRACKER_TURTLE_READER_BUFFER_SIZE) - 1) % TRACKER_TURTLE_READER_BUFFER_SIZE;
	_tmp0_ = string_substring ((const gchar*) (self->priv->tokens[last_index].begin.pos + strip), (glong) 0, (glong) ((gint) ((self->priv->tokens[last_index].end.pos - self->priv->tokens[last_index].begin.pos) - (2 * strip))));
	result = _tmp0_;
	return result;
}


static gchar* tracker_turtle_reader_resolve_prefixed_name (TrackerTurtleReader* self, const gchar* prefix, const gchar* local_name, GError** error) {
	gchar* result = NULL;
	gconstpointer _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* ns;
	gchar* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (prefix != NULL, NULL);
	g_return_val_if_fail (local_name != NULL, NULL);
	_tmp0_ = g_hash_table_lookup (self->priv->prefix_map, prefix);
	_tmp1_ = g_strdup ((const gchar*) _tmp0_);
	ns = _tmp1_;
	if (ns == NULL) {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		GError* _tmp4_ = NULL;
		GError* _tmp5_;
		_tmp2_ = g_strdup_printf ("use of undefined prefix `%s'", prefix);
		_tmp3_ = _tmp2_;
		_tmp4_ = tracker_turtle_reader_get_error (self, _tmp3_);
		_tmp5_ = _tmp4_;
		_g_free0 (_tmp3_);
		_inner_error_ = _tmp5_;
		if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (ns);
			return NULL;
		} else {
			_g_free0 (ns);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp6_ = g_strconcat (ns, local_name, NULL);
	result = _tmp6_;
	_g_free0 (ns);
	return result;
}


static void _vala_array_add10 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add11 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


gboolean tracker_turtle_reader_next (TrackerTurtleReader* self, GError** error) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	while (TRUE) {
		switch (self->priv->state) {
			case TRACKER_TURTLE_READER_STATE_INITIAL:
			{
				tracker_turtle_reader_next_token (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				self->priv->state = TRACKER_TURTLE_READER_STATE_BOS;
				continue;
			}
			case TRACKER_TURTLE_READER_STATE_BOS:
			{
				gboolean _tmp0_;
				gboolean _tmp1_;
				gboolean _tmp12_;
				gboolean _tmp13_;
				_tmp0_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_ATPREFIX, &_inner_error_);
				_tmp1_ = _tmp0_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				if (_tmp1_) {
					gchar* _tmp2_;
					gchar* ns;
					gboolean _tmp3_;
					gboolean _tmp4_;
					gchar* _tmp6_ = NULL;
					gchar* uri;
					gchar* _tmp7_;
					gchar* _tmp8_;
					_tmp2_ = g_strdup ("");
					ns = _tmp2_;
					_tmp3_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
					_tmp4_ = _tmp3_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (ns);
							return FALSE;
						} else {
							_g_free0 (ns);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp4_) {
						gchar* _tmp5_ = NULL;
						_tmp5_ = tracker_turtle_reader_get_last_string (self, 0);
						_g_free0 (ns);
						ns = _tmp5_;
					}
					tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (ns);
							return FALSE;
						} else {
							_g_free0 (ns);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (ns);
							return FALSE;
						} else {
							_g_free0 (ns);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					_tmp6_ = tracker_turtle_reader_get_last_string (self, 1);
					uri = _tmp6_;
					_tmp7_ = g_strdup (ns);
					_tmp8_ = g_strdup (uri);
					g_hash_table_insert (self->priv->prefix_map, _tmp7_, _tmp8_);
					tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_DOT, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (uri);
							_g_free0 (ns);
							return FALSE;
						} else {
							_g_free0 (uri);
							_g_free0 (ns);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					_g_free0 (uri);
					_g_free0 (ns);
					continue;
				} else {
					gboolean _tmp9_;
					gboolean _tmp10_;
					_tmp9_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_ATBASE, &_inner_error_);
					_tmp10_ = _tmp9_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							return FALSE;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp10_) {
						tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_DOT, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						continue;
					} else {
						TrackerSparqlTokenType _tmp11_;
						_tmp11_ = tracker_turtle_reader_current (self);
						if (_tmp11_ == TRACKER_SPARQL_TOKEN_TYPE_EOF) {
							result = FALSE;
							return result;
						}
					}
				}
				_tmp12_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
				_tmp13_ = _tmp12_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				if (_tmp13_) {
					gchar* _tmp14_ = NULL;
					gchar* _tmp15_;
					_tmp14_ = tracker_turtle_reader_get_last_string (self, 1);
					_tmp15_ = _tmp14_;
					tracker_turtle_reader_set_subject (self, _tmp15_);
					_g_free0 (_tmp15_);
					self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
					continue;
				} else {
					gboolean _tmp16_;
					gboolean _tmp17_;
					_tmp16_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
					_tmp17_ = _tmp16_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							return FALSE;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp17_) {
						gchar* _tmp18_ = NULL;
						gchar* ns;
						gchar* _tmp19_ = NULL;
						gchar* _tmp20_;
						gchar* _tmp21_ = NULL;
						gchar* _tmp22_;
						gchar* _tmp23_ = NULL;
						gchar* _tmp24_;
						gchar* _tmp25_;
						gchar* _tmp26_;
						_tmp18_ = tracker_turtle_reader_get_last_string (self, 0);
						ns = _tmp18_;
						tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp19_ = tracker_turtle_reader_get_last_string (self, 0);
						_tmp20_ = _tmp19_;
						_tmp21_ = string_substring (_tmp20_, (glong) 1, (glong) (-1));
						_tmp22_ = _tmp21_;
						_tmp23_ = tracker_turtle_reader_resolve_prefixed_name (self, ns, _tmp22_, &_inner_error_);
						_tmp24_ = _tmp23_;
						_g_free0 (_tmp22_);
						_g_free0 (_tmp20_);
						_tmp25_ = _tmp24_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp26_ = _tmp25_;
						tracker_turtle_reader_set_subject (self, _tmp26_);
						_g_free0 (_tmp26_);
						self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
						_g_free0 (ns);
						continue;
					} else {
						gboolean _tmp27_;
						gboolean _tmp28_;
						_tmp27_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						_tmp28_ = _tmp27_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						if (_tmp28_) {
							gchar* _tmp29_ = NULL;
							gchar* _tmp30_;
							gchar* _tmp31_ = NULL;
							gchar* _tmp32_;
							gchar* _tmp33_ = NULL;
							gchar* _tmp34_;
							gchar* _tmp35_;
							gchar* _tmp36_;
							_tmp29_ = tracker_turtle_reader_get_last_string (self, 0);
							_tmp30_ = _tmp29_;
							_tmp31_ = string_substring (_tmp30_, (glong) 1, (glong) (-1));
							_tmp32_ = _tmp31_;
							_tmp33_ = tracker_turtle_reader_resolve_prefixed_name (self, "", _tmp32_, &_inner_error_);
							_tmp34_ = _tmp33_;
							_g_free0 (_tmp32_);
							_g_free0 (_tmp30_);
							_tmp35_ = _tmp34_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							_tmp36_ = _tmp35_;
							tracker_turtle_reader_set_subject (self, _tmp36_);
							_g_free0 (_tmp36_);
							self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
							continue;
						} else {
							gboolean _tmp37_;
							gboolean _tmp38_;
							_tmp37_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_BLANK_NODE, &_inner_error_);
							_tmp38_ = _tmp37_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							if (_tmp38_) {
								gchar* _tmp39_ = NULL;
								gchar* _tmp40_;
								gchar* _tmp41_ = NULL;
								gchar* _tmp42_;
								gchar* _tmp43_ = NULL;
								gchar* _tmp44_;
								tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
										g_propagate_error (error, _inner_error_);
										return FALSE;
									} else {
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return FALSE;
									}
								}
								_tmp39_ = tracker_turtle_reader_get_last_string (self, 0);
								_tmp40_ = _tmp39_;
								_tmp41_ = string_substring (_tmp40_, (glong) 1, (glong) (-1));
								_tmp42_ = _tmp41_;
								_tmp43_ = tracker_turtle_reader_generate_bnodeid (self, _tmp42_);
								_tmp44_ = _tmp43_;
								tracker_turtle_reader_set_subject (self, _tmp44_);
								_g_free0 (_tmp44_);
								_g_free0 (_tmp42_);
								_g_free0 (_tmp40_);
								self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
								continue;
							} else {
								GError* _tmp45_ = NULL;
								_tmp45_ = tracker_turtle_reader_get_error (self, "expected subject");
								_inner_error_ = _tmp45_;
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
						}
					}
				}
			}
			case TRACKER_TURTLE_READER_STATE_SUBJECT:
			{
				gboolean _tmp46_;
				gboolean _tmp47_;
				_tmp46_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
				_tmp47_ = _tmp46_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				if (_tmp47_) {
					gchar* _tmp48_ = NULL;
					gchar* _tmp49_;
					_tmp48_ = tracker_turtle_reader_get_last_string (self, 1);
					_tmp49_ = _tmp48_;
					tracker_turtle_reader_set_predicate (self, _tmp49_);
					_g_free0 (_tmp49_);
					self->priv->state = TRACKER_TURTLE_READER_STATE_PREDICATE;
					continue;
				} else {
					gboolean _tmp50_;
					gboolean _tmp51_;
					_tmp50_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
					_tmp51_ = _tmp50_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							return FALSE;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp51_) {
						gchar* _tmp52_ = NULL;
						gchar* ns;
						gchar* _tmp53_ = NULL;
						gchar* _tmp54_;
						gchar* _tmp55_ = NULL;
						gchar* _tmp56_;
						gchar* _tmp57_ = NULL;
						gchar* _tmp58_;
						gchar* _tmp59_;
						gchar* _tmp60_;
						_tmp52_ = tracker_turtle_reader_get_last_string (self, 0);
						ns = _tmp52_;
						tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp53_ = tracker_turtle_reader_get_last_string (self, 0);
						_tmp54_ = _tmp53_;
						_tmp55_ = string_substring (_tmp54_, (glong) 1, (glong) (-1));
						_tmp56_ = _tmp55_;
						_tmp57_ = tracker_turtle_reader_resolve_prefixed_name (self, ns, _tmp56_, &_inner_error_);
						_tmp58_ = _tmp57_;
						_g_free0 (_tmp56_);
						_g_free0 (_tmp54_);
						_tmp59_ = _tmp58_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp60_ = _tmp59_;
						tracker_turtle_reader_set_predicate (self, _tmp60_);
						_g_free0 (_tmp60_);
						self->priv->state = TRACKER_TURTLE_READER_STATE_PREDICATE;
						_g_free0 (ns);
						continue;
					} else {
						gboolean _tmp61_;
						gboolean _tmp62_;
						_tmp61_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						_tmp62_ = _tmp61_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						if (_tmp62_) {
							gchar* _tmp63_ = NULL;
							gchar* _tmp64_;
							gchar* _tmp65_ = NULL;
							gchar* _tmp66_;
							gchar* _tmp67_ = NULL;
							gchar* _tmp68_;
							gchar* _tmp69_;
							gchar* _tmp70_;
							_tmp63_ = tracker_turtle_reader_get_last_string (self, 0);
							_tmp64_ = _tmp63_;
							_tmp65_ = string_substring (_tmp64_, (glong) 1, (glong) (-1));
							_tmp66_ = _tmp65_;
							_tmp67_ = tracker_turtle_reader_resolve_prefixed_name (self, "", _tmp66_, &_inner_error_);
							_tmp68_ = _tmp67_;
							_g_free0 (_tmp66_);
							_g_free0 (_tmp64_);
							_tmp69_ = _tmp68_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							_tmp70_ = _tmp69_;
							tracker_turtle_reader_set_predicate (self, _tmp70_);
							_g_free0 (_tmp70_);
							self->priv->state = TRACKER_TURTLE_READER_STATE_PREDICATE;
							continue;
						} else {
							gboolean _tmp71_;
							gboolean _tmp72_;
							_tmp71_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_A, &_inner_error_);
							_tmp72_ = _tmp71_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							if (_tmp72_) {
								tracker_turtle_reader_set_predicate (self, "http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
								self->priv->state = TRACKER_TURTLE_READER_STATE_PREDICATE;
								continue;
							} else {
								GError* _tmp73_ = NULL;
								_tmp73_ = tracker_turtle_reader_get_error (self, "expected predicate");
								_inner_error_ = _tmp73_;
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
						}
					}
				}
			}
			case TRACKER_TURTLE_READER_STATE_PREDICATE:
			{
				gboolean _tmp74_;
				gboolean _tmp75_;
				_tmp74_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
				_tmp75_ = _tmp74_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				if (_tmp75_) {
					gchar* _tmp76_ = NULL;
					gchar* _tmp77_;
					_tmp76_ = tracker_turtle_reader_get_last_string (self, 1);
					_tmp77_ = _tmp76_;
					tracker_turtle_reader_set_object (self, _tmp77_);
					_g_free0 (_tmp77_);
					tracker_turtle_reader_set_object_is_uri (self, TRUE);
					self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
					result = TRUE;
					return result;
				} else {
					gboolean _tmp78_;
					gboolean _tmp79_;
					_tmp78_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
					_tmp79_ = _tmp78_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							return FALSE;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp79_) {
						gchar* _tmp80_ = NULL;
						gchar* ns;
						gchar* _tmp81_ = NULL;
						gchar* _tmp82_;
						gchar* _tmp83_ = NULL;
						gchar* _tmp84_;
						gchar* _tmp85_ = NULL;
						gchar* _tmp86_;
						gchar* _tmp87_;
						gchar* _tmp88_;
						_tmp80_ = tracker_turtle_reader_get_last_string (self, 0);
						ns = _tmp80_;
						tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp81_ = tracker_turtle_reader_get_last_string (self, 0);
						_tmp82_ = _tmp81_;
						_tmp83_ = string_substring (_tmp82_, (glong) 1, (glong) (-1));
						_tmp84_ = _tmp83_;
						_tmp85_ = tracker_turtle_reader_resolve_prefixed_name (self, ns, _tmp84_, &_inner_error_);
						_tmp86_ = _tmp85_;
						_g_free0 (_tmp84_);
						_g_free0 (_tmp82_);
						_tmp87_ = _tmp86_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								_g_free0 (ns);
								return FALSE;
							} else {
								_g_free0 (ns);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						_tmp88_ = _tmp87_;
						tracker_turtle_reader_set_object (self, _tmp88_);
						_g_free0 (_tmp88_);
						tracker_turtle_reader_set_object_is_uri (self, TRUE);
						self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
						result = TRUE;
						_g_free0 (ns);
						return result;
					} else {
						gboolean _tmp89_;
						gboolean _tmp90_;
						_tmp89_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
						_tmp90_ = _tmp89_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						if (_tmp90_) {
							gchar* _tmp91_ = NULL;
							gchar* _tmp92_;
							gchar* _tmp93_ = NULL;
							gchar* _tmp94_;
							gchar* _tmp95_ = NULL;
							gchar* _tmp96_;
							gchar* _tmp97_;
							gchar* _tmp98_;
							_tmp91_ = tracker_turtle_reader_get_last_string (self, 0);
							_tmp92_ = _tmp91_;
							_tmp93_ = string_substring (_tmp92_, (glong) 1, (glong) (-1));
							_tmp94_ = _tmp93_;
							_tmp95_ = tracker_turtle_reader_resolve_prefixed_name (self, "", _tmp94_, &_inner_error_);
							_tmp96_ = _tmp95_;
							_g_free0 (_tmp94_);
							_g_free0 (_tmp92_);
							_tmp97_ = _tmp96_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							_tmp98_ = _tmp97_;
							tracker_turtle_reader_set_object (self, _tmp98_);
							_g_free0 (_tmp98_);
							tracker_turtle_reader_set_object_is_uri (self, TRUE);
							self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
							result = TRUE;
							return result;
						} else {
							gboolean _tmp99_;
							gboolean _tmp100_;
							_tmp99_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_BLANK_NODE, &_inner_error_);
							_tmp100_ = _tmp99_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							if (_tmp100_) {
								gchar* _tmp101_ = NULL;
								gchar* _tmp102_;
								gchar* _tmp103_ = NULL;
								gchar* _tmp104_;
								gchar* _tmp105_ = NULL;
								gchar* _tmp106_;
								tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
										g_propagate_error (error, _inner_error_);
										return FALSE;
									} else {
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return FALSE;
									}
								}
								_tmp101_ = tracker_turtle_reader_get_last_string (self, 0);
								_tmp102_ = _tmp101_;
								_tmp103_ = string_substring (_tmp102_, (glong) 1, (glong) (-1));
								_tmp104_ = _tmp103_;
								_tmp105_ = tracker_turtle_reader_generate_bnodeid (self, _tmp104_);
								_tmp106_ = _tmp105_;
								tracker_turtle_reader_set_object (self, _tmp106_);
								_g_free0 (_tmp106_);
								_g_free0 (_tmp104_);
								_g_free0 (_tmp102_);
								tracker_turtle_reader_set_object_is_uri (self, TRUE);
								self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
								result = TRUE;
								return result;
							} else {
								gboolean _tmp107_;
								gboolean _tmp108_;
								_tmp107_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_OPEN_BRACKET, &_inner_error_);
								_tmp108_ = _tmp107_;
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
										g_propagate_error (error, _inner_error_);
										return FALSE;
									} else {
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return FALSE;
									}
								}
								if (_tmp108_) {
									gchar* _tmp109_;
									gchar* _tmp110_;
									gchar* _tmp111_ = NULL;
									gchar* _tmp112_;
									_tmp109_ = g_strdup (self->priv->_subject);
									_vala_array_add10 (&self->priv->subject_stack, &self->priv->subject_stack_length1, &self->priv->_subject_stack_size_, _tmp109_);
									_tmp110_ = g_strdup (self->priv->_predicate);
									_vala_array_add11 (&self->priv->predicate_stack, &self->priv->predicate_stack_length1, &self->priv->_predicate_stack_size_, _tmp110_);
									_tmp111_ = tracker_turtle_reader_generate_bnodeid (self, NULL);
									_tmp112_ = _tmp111_;
									tracker_turtle_reader_set_subject (self, _tmp112_);
									_g_free0 (_tmp112_);
									self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
									continue;
								} else {
									gboolean _tmp113_ = FALSE;
									gboolean _tmp114_;
									gboolean _tmp115_;
									_tmp114_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL1, &_inner_error_);
									_tmp115_ = _tmp114_;
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
											g_propagate_error (error, _inner_error_);
											return FALSE;
										} else {
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return FALSE;
										}
									}
									if (_tmp115_) {
										_tmp113_ = TRUE;
									} else {
										gboolean _tmp116_;
										gboolean _tmp117_;
										_tmp116_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL2, &_inner_error_);
										_tmp117_ = _tmp116_;
										if (_inner_error_ != NULL) {
											if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
												g_propagate_error (error, _inner_error_);
												return FALSE;
											} else {
												g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
												g_clear_error (&_inner_error_);
												return FALSE;
											}
										}
										_tmp113_ = _tmp117_;
									}
									if (_tmp113_) {
										GString* _tmp118_ = NULL;
										GString* sb;
										gchar* _tmp119_ = NULL;
										gchar* s;
										const gchar* p;
										gint _tmp120_;
										const gchar* end;
										gboolean _tmp122_;
										gboolean _tmp123_;
										_tmp118_ = g_string_new ("");
										sb = _tmp118_;
										_tmp119_ = tracker_turtle_reader_get_last_string (self, 1);
										s = _tmp119_;
										p = s;
										_tmp120_ = strlen (s);
										end = p + _tmp120_;
										while (TRUE) {
											const gchar* _tmp121_ = NULL;
											const gchar* q;
											if (!(((glong) p) < ((glong) end))) {
												break;
											}
											_tmp121_ = strchr (p, (gint) '\\');
											q = _tmp121_;
											if (q == NULL) {
												g_string_append_len (sb, p, (gssize) ((glong) (end - p)));
												p = end;
											} else {
												g_string_append_len (sb, p, (gssize) ((glong) (q - p)));
												p = q + 1;
												switch (((gchar*) p)[0]) {
													case '\'':
													case '"':
													case '\\':
													{
														g_string_append_c (sb, ((gchar*) p)[0]);
														break;
													}
													case 'b':
													{
														g_string_append_c (sb, '\b');
														break;
													}
													case 'f':
													{
														g_string_append_c (sb, '\f');
														break;
													}
													case 'n':
													{
														g_string_append_c (sb, '\n');
														break;
													}
													case 'r':
													{
														g_string_append_c (sb, '\r');
														break;
													}
													case 't':
													{
														g_string_append_c (sb, '\t');
														break;
													}
													default:
													break;
												}
												p++;
											}
										}
										tracker_turtle_reader_set_object (self, sb->str);
										tracker_turtle_reader_set_object_is_uri (self, FALSE);
										self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
										_tmp122_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DOUBLE_CIRCUMFLEX, &_inner_error_);
										_tmp123_ = _tmp122_;
										if (_inner_error_ != NULL) {
											if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
												g_propagate_error (error, _inner_error_);
												_g_free0 (s);
												_g_string_free0 (sb);
												return FALSE;
											} else {
												_g_free0 (s);
												_g_string_free0 (sb);
												g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
												g_clear_error (&_inner_error_);
												return FALSE;
											}
										}
										if (_tmp123_) {
											gboolean _tmp124_;
											gboolean _tmp125_;
											_tmp124_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
											_tmp125_ = _tmp124_;
											if (_inner_error_ != NULL) {
												if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
													g_propagate_error (error, _inner_error_);
													_g_free0 (s);
													_g_string_free0 (sb);
													return FALSE;
												} else {
													_g_free0 (s);
													_g_string_free0 (sb);
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
													g_clear_error (&_inner_error_);
													return FALSE;
												}
											}
											if (!_tmp125_) {
												tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														_g_free0 (s);
														_g_string_free0 (sb);
														return FALSE;
													} else {
														_g_free0 (s);
														_g_string_free0 (sb);
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														_g_free0 (s);
														_g_string_free0 (sb);
														return FALSE;
													} else {
														_g_free0 (s);
														_g_string_free0 (sb);
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
											}
										}
										result = TRUE;
										_g_free0 (s);
										_g_string_free0 (sb);
										return result;
									} else {
										gboolean _tmp126_ = FALSE;
										gboolean _tmp127_;
										gboolean _tmp128_;
										_tmp127_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL_LONG1, &_inner_error_);
										_tmp128_ = _tmp127_;
										if (_inner_error_ != NULL) {
											if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
												g_propagate_error (error, _inner_error_);
												return FALSE;
											} else {
												g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
												g_clear_error (&_inner_error_);
												return FALSE;
											}
										}
										if (_tmp128_) {
											_tmp126_ = TRUE;
										} else {
											gboolean _tmp129_;
											gboolean _tmp130_;
											_tmp129_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_STRING_LITERAL_LONG2, &_inner_error_);
											_tmp130_ = _tmp129_;
											if (_inner_error_ != NULL) {
												if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
													g_propagate_error (error, _inner_error_);
													return FALSE;
												} else {
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
													g_clear_error (&_inner_error_);
													return FALSE;
												}
											}
											_tmp126_ = _tmp130_;
										}
										if (_tmp126_) {
											gchar* _tmp131_ = NULL;
											gchar* _tmp132_;
											gboolean _tmp133_;
											gboolean _tmp134_;
											_tmp131_ = tracker_turtle_reader_get_last_string (self, 3);
											_tmp132_ = _tmp131_;
											tracker_turtle_reader_set_object (self, _tmp132_);
											_g_free0 (_tmp132_);
											tracker_turtle_reader_set_object_is_uri (self, FALSE);
											self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
											_tmp133_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DOUBLE_CIRCUMFLEX, &_inner_error_);
											_tmp134_ = _tmp133_;
											if (_inner_error_ != NULL) {
												if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
													g_propagate_error (error, _inner_error_);
													return FALSE;
												} else {
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
													g_clear_error (&_inner_error_);
													return FALSE;
												}
											}
											if (_tmp134_) {
												gboolean _tmp135_;
												gboolean _tmp136_;
												_tmp135_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_IRI_REF, &_inner_error_);
												_tmp136_ = _tmp135_;
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														return FALSE;
													} else {
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												if (!_tmp136_) {
													tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_PN_PREFIX, &_inner_error_);
													if (_inner_error_ != NULL) {
														if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
															g_propagate_error (error, _inner_error_);
															return FALSE;
														} else {
															g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
															g_clear_error (&_inner_error_);
															return FALSE;
														}
													}
													tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_COLON, &_inner_error_);
													if (_inner_error_ != NULL) {
														if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
															g_propagate_error (error, _inner_error_);
															return FALSE;
														} else {
															g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
															g_clear_error (&_inner_error_);
															return FALSE;
														}
													}
												}
											}
											result = TRUE;
											return result;
										} else {
											gboolean _tmp137_ = FALSE;
											gboolean _tmp138_ = FALSE;
											gboolean _tmp139_ = FALSE;
											gboolean _tmp140_ = FALSE;
											gboolean _tmp141_;
											gboolean _tmp142_;
											_tmp141_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_INTEGER, &_inner_error_);
											_tmp142_ = _tmp141_;
											if (_inner_error_ != NULL) {
												if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
													g_propagate_error (error, _inner_error_);
													return FALSE;
												} else {
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
													g_clear_error (&_inner_error_);
													return FALSE;
												}
											}
											if (_tmp142_) {
												_tmp140_ = TRUE;
											} else {
												gboolean _tmp143_;
												gboolean _tmp144_;
												_tmp143_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DECIMAL, &_inner_error_);
												_tmp144_ = _tmp143_;
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														return FALSE;
													} else {
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												_tmp140_ = _tmp144_;
											}
											if (_tmp140_) {
												_tmp139_ = TRUE;
											} else {
												gboolean _tmp145_;
												gboolean _tmp146_;
												_tmp145_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DOUBLE, &_inner_error_);
												_tmp146_ = _tmp145_;
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														return FALSE;
													} else {
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												_tmp139_ = _tmp146_;
											}
											if (_tmp139_) {
												_tmp138_ = TRUE;
											} else {
												gboolean _tmp147_;
												gboolean _tmp148_;
												_tmp147_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_TRUE, &_inner_error_);
												_tmp148_ = _tmp147_;
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														return FALSE;
													} else {
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												_tmp138_ = _tmp148_;
											}
											if (_tmp138_) {
												_tmp137_ = TRUE;
											} else {
												gboolean _tmp149_;
												gboolean _tmp150_;
												_tmp149_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_FALSE, &_inner_error_);
												_tmp150_ = _tmp149_;
												if (_inner_error_ != NULL) {
													if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
														g_propagate_error (error, _inner_error_);
														return FALSE;
													} else {
														g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
														g_clear_error (&_inner_error_);
														return FALSE;
													}
												}
												_tmp137_ = _tmp150_;
											}
											if (_tmp137_) {
												gchar* _tmp151_ = NULL;
												gchar* _tmp152_;
												_tmp151_ = tracker_turtle_reader_get_last_string (self, 0);
												_tmp152_ = _tmp151_;
												tracker_turtle_reader_set_object (self, _tmp152_);
												_g_free0 (_tmp152_);
												tracker_turtle_reader_set_object_is_uri (self, FALSE);
												self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
												result = TRUE;
												return result;
											} else {
												GError* _tmp153_ = NULL;
												_tmp153_ = tracker_turtle_reader_get_error (self, "expected object");
												_inner_error_ = _tmp153_;
												if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
													g_propagate_error (error, _inner_error_);
													return FALSE;
												} else {
													g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
													g_clear_error (&_inner_error_);
													return FALSE;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			case TRACKER_TURTLE_READER_STATE_OBJECT:
			{
				gboolean _tmp154_;
				gboolean _tmp155_;
				_tmp154_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_COMMA, &_inner_error_);
				_tmp155_ = _tmp154_;
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
						g_propagate_error (error, _inner_error_);
						return FALSE;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return FALSE;
					}
				}
				if (_tmp155_) {
					self->priv->state = TRACKER_TURTLE_READER_STATE_PREDICATE;
					continue;
				} else {
					gboolean _tmp156_;
					gboolean _tmp157_;
					_tmp156_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_SEMICOLON, &_inner_error_);
					_tmp157_ = _tmp156_;
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
							g_propagate_error (error, _inner_error_);
							return FALSE;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return FALSE;
						}
					}
					if (_tmp157_) {
						gboolean _tmp158_;
						gboolean _tmp159_;
						_tmp158_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DOT, &_inner_error_);
						_tmp159_ = _tmp158_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
								g_propagate_error (error, _inner_error_);
								return FALSE;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return FALSE;
							}
						}
						if (_tmp159_) {
							self->priv->state = TRACKER_TURTLE_READER_STATE_BOS;
							continue;
						}
						self->priv->state = TRACKER_TURTLE_READER_STATE_SUBJECT;
						continue;
					} else {
						if (self->priv->subject_stack_length1 > 0) {
							tracker_turtle_reader_expect (self, TRACKER_SPARQL_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							tracker_turtle_reader_set_object (self, self->priv->_subject);
							tracker_turtle_reader_set_object_is_uri (self, TRUE);
							tracker_turtle_reader_set_subject (self, self->priv->subject_stack[self->priv->subject_stack_length1 - 1]);
							self->priv->subject_stack_length1--;
							tracker_turtle_reader_set_predicate (self, self->priv->predicate_stack[self->priv->predicate_stack_length1 - 1]);
							self->priv->predicate_stack_length1--;
							self->priv->state = TRACKER_TURTLE_READER_STATE_OBJECT;
							result = TRUE;
							return result;
						} else {
							gboolean _tmp160_;
							gboolean _tmp161_;
							_tmp160_ = tracker_turtle_reader_accept (self, TRACKER_SPARQL_TOKEN_TYPE_DOT, &_inner_error_);
							_tmp161_ = _tmp160_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
							if (_tmp161_) {
								self->priv->state = TRACKER_TURTLE_READER_STATE_BOS;
								continue;
							} else {
								GError* _tmp162_ = NULL;
								_tmp162_ = tracker_turtle_reader_get_error (self, "expected comma, semicolon, or dot");
								_inner_error_ = _tmp162_;
								if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
									g_propagate_error (error, _inner_error_);
									return FALSE;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return FALSE;
								}
							}
						}
					}
				}
			}
			default:
			break;
		}
	}
}


static gpointer _g_error_copy0 (gpointer self) {
	return self ? g_error_copy (self) : NULL;
}


void tracker_turtle_reader_load (const gchar* path, GError** error) {
	TrackerTurtleReader* _tmp0_ = NULL;
	TrackerTurtleReader* reader;
	GError * _inner_error_ = NULL;
	g_return_if_fail (path != NULL);
	tracker_data_begin_transaction (&_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
			goto __catch4_tracker_sparql_error;
		}
		if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
			goto __catch4_tracker_db_interface_error;
		}
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp0_ = tracker_turtle_reader_new (path, &_inner_error_);
	reader = _tmp0_;
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
			goto __catch4_tracker_sparql_error;
		}
		if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
			goto __catch4_tracker_db_interface_error;
		}
		goto __finally4;
	}
	while (TRUE) {
		gboolean _tmp1_;
		gboolean _tmp2_;
		_tmp1_ = tracker_turtle_reader_next (reader, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			_g_object_unref0 (reader);
			if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
				goto __catch4_tracker_sparql_error;
			}
			if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
				goto __catch4_tracker_db_interface_error;
			}
			_g_object_unref0 (reader);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		if (!_tmp2_) {
			break;
		}
		if (reader->priv->_object_is_uri) {
			tracker_data_insert_statement_with_uri (reader->priv->_graph, reader->priv->_subject, reader->priv->_predicate, reader->priv->_object, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (reader);
				if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
					goto __catch4_tracker_sparql_error;
				}
				if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
					goto __catch4_tracker_db_interface_error;
				}
				_g_object_unref0 (reader);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		} else {
			tracker_data_insert_statement_with_string (reader->priv->_graph, reader->priv->_subject, reader->priv->_predicate, reader->priv->_object, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (reader);
				if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
					goto __catch4_tracker_sparql_error;
				}
				if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
					goto __catch4_tracker_db_interface_error;
				}
				goto __finally4;
			}
		}
		tracker_data_update_buffer_might_flush (&_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (reader);
			if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
				goto __catch4_tracker_sparql_error;
			}
			if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
				goto __catch4_tracker_db_interface_error;
			}
			_g_object_unref0 (reader);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	tracker_data_commit_transaction (&_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (reader);
		if (_inner_error_->domain == TRACKER_SPARQL_ERROR) {
			goto __catch4_tracker_sparql_error;
		}
		if (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR) {
			goto __catch4_tracker_db_interface_error;
		}
		_g_object_unref0 (reader);
		g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (reader);
	goto __finally4;
	__catch4_tracker_sparql_error:
	{
		GError * e;
		GError* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		tracker_data_rollback_transaction ();
		_tmp3_ = _g_error_copy0 (e);
		_inner_error_ = _tmp3_;
		_g_error_free0 (e);
		goto __finally4;
	}
	goto __finally4;
	__catch4_tracker_db_interface_error:
	{
		GError * e;
		GError* _tmp4_;
		e = _inner_error_;
		_inner_error_ = NULL;
		tracker_data_rollback_transaction ();
		_tmp4_ = _g_error_copy0 (e);
		_inner_error_ = _tmp4_;
		_g_error_free0 (e);
		goto __finally4;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		if ((((_inner_error_->domain == G_FILE_ERROR) || (_inner_error_->domain == TRACKER_SPARQL_ERROR)) || (_inner_error_->domain == TRACKER_DATE_ERROR)) || (_inner_error_->domain == TRACKER_DB_INTERFACE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


const gchar* tracker_turtle_reader_get_graph (TrackerTurtleReader* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_graph;
	return result;
}


static void tracker_turtle_reader_set_graph (TrackerTurtleReader* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_graph);
	self->priv->_graph = _tmp0_;
	g_object_notify ((GObject *) self, "graph");
}


const gchar* tracker_turtle_reader_get_subject (TrackerTurtleReader* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_subject;
	return result;
}


static void tracker_turtle_reader_set_subject (TrackerTurtleReader* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_subject);
	self->priv->_subject = _tmp0_;
	g_object_notify ((GObject *) self, "subject");
}


const gchar* tracker_turtle_reader_get_predicate (TrackerTurtleReader* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_predicate;
	return result;
}


static void tracker_turtle_reader_set_predicate (TrackerTurtleReader* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_predicate);
	self->priv->_predicate = _tmp0_;
	g_object_notify ((GObject *) self, "predicate");
}


const gchar* tracker_turtle_reader_get_object (TrackerTurtleReader* self) {
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_object;
	return result;
}


static void tracker_turtle_reader_set_object (TrackerTurtleReader* self, const gchar* value) {
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_object);
	self->priv->_object = _tmp0_;
	g_object_notify ((GObject *) self, "object");
}


gboolean tracker_turtle_reader_get_object_is_uri (TrackerTurtleReader* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_object_is_uri;
	return result;
}


static void tracker_turtle_reader_set_object_is_uri (TrackerTurtleReader* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_object_is_uri = value;
	g_object_notify ((GObject *) self, "object-is-uri");
}


static TrackerTurtleReaderTokenInfo* tracker_turtle_reader_token_info_dup (const TrackerTurtleReaderTokenInfo* self) {
	TrackerTurtleReaderTokenInfo* dup;
	dup = g_new0 (TrackerTurtleReaderTokenInfo, 1);
	memcpy (dup, self, sizeof (TrackerTurtleReaderTokenInfo));
	return dup;
}


static void tracker_turtle_reader_token_info_free (TrackerTurtleReaderTokenInfo* self) {
	g_free (self);
}


static GType tracker_turtle_reader_token_info_get_type (void) {
	static volatile gsize tracker_turtle_reader_token_info_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_turtle_reader_token_info_type_id__volatile)) {
		GType tracker_turtle_reader_token_info_type_id;
		tracker_turtle_reader_token_info_type_id = g_boxed_type_register_static ("TrackerTurtleReaderTokenInfo", (GBoxedCopyFunc) tracker_turtle_reader_token_info_dup, (GBoxedFreeFunc) tracker_turtle_reader_token_info_free);
		g_once_init_leave (&tracker_turtle_reader_token_info_type_id__volatile, tracker_turtle_reader_token_info_type_id);
	}
	return tracker_turtle_reader_token_info_type_id__volatile;
}


static void tracker_turtle_reader_class_init (TrackerTurtleReaderClass * klass) {
	tracker_turtle_reader_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TrackerTurtleReaderPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_tracker_turtle_reader_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_tracker_turtle_reader_set_property;
	G_OBJECT_CLASS (klass)->finalize = tracker_turtle_reader_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_TURTLE_READER_GRAPH, g_param_spec_string ("graph", "graph", "graph", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_TURTLE_READER_SUBJECT, g_param_spec_string ("subject", "subject", "subject", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_TURTLE_READER_PREDICATE, g_param_spec_string ("predicate", "predicate", "predicate", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_TURTLE_READER_OBJECT, g_param_spec_string ("object", "object", "object", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TRACKER_TURTLE_READER_OBJECT_IS_URI, g_param_spec_boolean ("object-is-uri", "object-is-uri", "object-is-uri", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void tracker_turtle_reader_instance_init (TrackerTurtleReader * self) {
	self->priv = TRACKER_TURTLE_READER_GET_PRIVATE (self);
	self->priv->bnodeid = 0;
}


static void tracker_turtle_reader_finalize (GObject* obj) {
	TrackerTurtleReader * self;
	self = TRACKER_TURTLE_READER (obj);
	_g_object_unref0 (self->priv->scanner);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	_g_free0 (self->priv->_graph);
	_g_free0 (self->priv->_subject);
	_g_free0 (self->priv->_predicate);
	_g_free0 (self->priv->_object);
	_g_hash_table_unref0 (self->priv->prefix_map);
	self->priv->subject_stack = (_vala_array_free (self->priv->subject_stack, self->priv->subject_stack_length1, (GDestroyNotify) g_free), NULL);
	self->priv->predicate_stack = (_vala_array_free (self->priv->predicate_stack, self->priv->predicate_stack_length1, (GDestroyNotify) g_free), NULL);
	self->priv->base_uuid = (g_free (self->priv->base_uuid), NULL);
	_g_mapped_file_unref0 (self->priv->mapped_file);
	G_OBJECT_CLASS (tracker_turtle_reader_parent_class)->finalize (obj);
}


GType tracker_turtle_reader_get_type (void) {
	static volatile gsize tracker_turtle_reader_type_id__volatile = 0;
	if (g_once_init_enter (&tracker_turtle_reader_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TrackerTurtleReaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tracker_turtle_reader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TrackerTurtleReader), 0, (GInstanceInitFunc) tracker_turtle_reader_instance_init, NULL };
		GType tracker_turtle_reader_type_id;
		tracker_turtle_reader_type_id = g_type_register_static (G_TYPE_OBJECT, "TrackerTurtleReader", &g_define_type_info, 0);
		g_once_init_leave (&tracker_turtle_reader_type_id__volatile, tracker_turtle_reader_type_id);
	}
	return tracker_turtle_reader_type_id__volatile;
}


static void _vala_tracker_turtle_reader_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TrackerTurtleReader * self;
	self = TRACKER_TURTLE_READER (object);
	switch (property_id) {
		case TRACKER_TURTLE_READER_GRAPH:
		g_value_set_string (value, tracker_turtle_reader_get_graph (self));
		break;
		case TRACKER_TURTLE_READER_SUBJECT:
		g_value_set_string (value, tracker_turtle_reader_get_subject (self));
		break;
		case TRACKER_TURTLE_READER_PREDICATE:
		g_value_set_string (value, tracker_turtle_reader_get_predicate (self));
		break;
		case TRACKER_TURTLE_READER_OBJECT:
		g_value_set_string (value, tracker_turtle_reader_get_object (self));
		break;
		case TRACKER_TURTLE_READER_OBJECT_IS_URI:
		g_value_set_boolean (value, tracker_turtle_reader_get_object_is_uri (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_tracker_turtle_reader_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	TrackerTurtleReader * self;
	self = TRACKER_TURTLE_READER (object);
	switch (property_id) {
		case TRACKER_TURTLE_READER_GRAPH:
		tracker_turtle_reader_set_graph (self, g_value_get_string (value));
		break;
		case TRACKER_TURTLE_READER_SUBJECT:
		tracker_turtle_reader_set_subject (self, g_value_get_string (value));
		break;
		case TRACKER_TURTLE_READER_PREDICATE:
		tracker_turtle_reader_set_predicate (self, g_value_get_string (value));
		break;
		case TRACKER_TURTLE_READER_OBJECT:
		tracker_turtle_reader_set_object (self, g_value_get_string (value));
		break;
		case TRACKER_TURTLE_READER_OBJECT_IS_URI:
		tracker_turtle_reader_set_object_is_uri (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



